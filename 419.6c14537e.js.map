{"version":3,"file":"419.6c14537e.js","mappings":"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","sources":["webpack://kas-ui/./src/app/modules/Metrics/components/ChartEmptyState/ChartEmptyState.tsx","webpack://kas-ui/./src/app/modules/Metrics/utils/utils.ts","webpack://kas-ui/./src/app/modules/Metrics/components/ChartPopover/ChartPopover.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/UsedDiskSpaceChart/UsedDiskSpaceChart.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/MessagesChart/MessagesChart.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/IncomingOutgoingBytesPerTopic/IncomingOutgoingBytesPerTopic.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/LogSizePerPartitionChart/LogSizePerPartitionChart.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ChartToolbar/FilterByTopic.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ChartToolbar/FilterByTime.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ChartToolbar/ChartToolbar.tsx"],"sourcesContent":["import React from 'react';\nimport {\n  EmptyState,\n  EmptyStateVariant,\n  EmptyStateBody,\n  EmptyStateIcon,\n  Title,\n  Button,\n} from '@patternfly/react-core';\nimport TachometerAltIcon from '@patternfly/react-icons/dist/js/icons/tachometer-alt-icon';\nimport WrenchIcon from '@patternfly/react-icons/dist/js/icons/wrench-icon';\nimport FilterIcon from '@patternfly/react-icons/dist/js/icons/filter-icon';\n\ntype ChartEmptyState = {\n  title: string;\n  body: string;\n  noData?: boolean;\n  noTopics?: boolean;\n  noFilter?: boolean;\n  onCreateTopic?: () => void;\n};\n\nexport const ChartEmptyState = ({\n  title,\n  body,\n  noData,\n  noTopics,\n  noFilter,\n  onCreateTopic,\n}: ChartEmptyState) => {\n  const getIcon = () => {\n    if (noData) {\n      return TachometerAltIcon;\n    } else if (noTopics) {\n      return WrenchIcon;\n    } else if (noFilter) {\n      return FilterIcon;\n    }\n    return;\n  };\n\n  return (\n    <EmptyState variant={EmptyStateVariant.xs}>\n      <EmptyStateIcon icon={getIcon()} />\n      <Title headingLevel='h3' size='lg'>\n        {title}\n      </Title>\n      <EmptyStateBody>\n        {body}\n        <br />\n        <br />\n        {noTopics && (\n          <Button variant='primary' onClick={onCreateTopic}>\n            Create topic\n          </Button>\n        )}\n      </EmptyStateBody>\n    </EmptyState>\n  );\n};\n","import byteSize from 'byte-size';\n\nexport const getLargestByteSize = (data1, data2) => {\n  let currentByteSize = 'B';\n\n  data1 = data1 && (data1.sortedData ? data1.sortedData : data1.data);\n  data2 = data2 && (data2.sortedData ? data2.sortedData : data2.data);\n\n  data1 &&\n    data1.map((datum) => {\n      datum.bytes.forEach((value) => {\n        const byteString = byteSize(value).unit;\n        if (byteString === 'kiB') {\n          if (currentByteSize === 'B') {\n            currentByteSize = 'kiB';\n          }\n        }\n        if (byteString === 'MiB') {\n          if (currentByteSize === 'B' || currentByteSize === 'kiB') {\n            currentByteSize = 'MiB';\n          }\n        }\n        if (byteString === 'GiB') {\n          if (\n            currentByteSize === 'B' ||\n            currentByteSize === 'kiB' ||\n            currentByteSize === 'MiB'\n          ) {\n            currentByteSize = 'GiB';\n          }\n        }\n      });\n    });\n\n  data2 &&\n    data2.map((datum) => {\n      datum.bytes.forEach((value) => {\n        const byteString = byteSize(value).unit;\n        if (byteString === 'kiB') {\n          if (currentByteSize === 'B') {\n            currentByteSize = 'kiB';\n          }\n        }\n        if (byteString === 'MiB') {\n          if (currentByteSize === 'B' || currentByteSize === 'kiB') {\n            currentByteSize = 'MiB';\n          }\n        }\n        if (byteString === 'GiB') {\n          if (\n            currentByteSize === 'B' ||\n            currentByteSize === 'kiB' ||\n            currentByteSize === 'MiB'\n          ) {\n            currentByteSize = 'GiB';\n          }\n        }\n      });\n    });\n\n  return currentByteSize;\n};\n\nexport const convertToSpecifiedByte = (bytes, largestByteSize) => {\n  if (largestByteSize === 'B') {\n    return Math.round(bytes * 10) / 10;\n  }\n  if (largestByteSize === 'kiB') {\n    return Math.round((bytes / 1024) * 10) / 10;\n  }\n  if (largestByteSize === 'MiB') {\n    return Math.round((bytes / 1024 / 1024) * 10) / 10;\n  }\n  if (largestByteSize === 'GiB') {\n    return Math.round((bytes / 1024 / 1024 / 1024) * 10) / 10;\n  }\n  return;\n};\n\nexport const getMaxValueOfArray = (data) => {\n  const max = data.reduce(function (prev, current) {\n    return prev.bytes > current.bytes ? prev : current;\n  });\n  return max.bytes;\n};\n\n//Add a scalable logic to set duration and interval\nexport const formatTime = (selection: string) => {\n  let timeDuration = 6;\n  let timeInterval = 1 * 60; //in minutes\n  switch (selection) {\n    case 'Last 5 minutes':\n      timeDuration = 5 / 60;\n      timeInterval = 1;\n      break;\n    case 'Last 15 minutes':\n      timeDuration = 15 / 60;\n      timeInterval = 3;\n      break;\n    case 'Last 30 minutes':\n      timeDuration = 30 / 60;\n      timeInterval = 5;\n      break;\n    case 'Last 1 hour':\n      timeDuration = 1;\n      timeInterval = 10;\n      break;\n    case 'Last 3 hours':\n      timeDuration = 3;\n      timeInterval = 30;\n      break;\n    case 'Last 6 hours':\n      timeDuration = 6;\n      timeInterval = 1 * 60;\n      break;\n    case 'Last 12 hours':\n      timeDuration = 12;\n      timeInterval = 2 * 60;\n      break;\n    case 'Last 24 hours':\n      timeDuration = 24;\n      timeInterval = 4 * 60;\n      break;\n    case 'Last 2 days':\n      timeDuration = 2 * 24;\n      timeInterval = 8 * 60;\n      break;\n    case 'Last 7 days':\n      timeDuration = 7 * 24;\n      timeInterval = 24 * 60;\n      break;\n  }\n  return { timeDuration, timeInterval };\n};\n","import { Popover } from '@patternfly/react-core';\nimport OutlinedQuestionCircleIcon from '@patternfly/react-icons/dist/js/icons/outlined-question-circle-icon';\nimport React from 'react';\n\ntype ChartPopoverProps = {\n  title: string;\n  description: string;\n};\n\nexport const ChartPopover = ({ title, description }: ChartPopoverProps) => {\n  return (\n    <Popover\n      aria-label='Basic popover'\n      headerContent={<div>{title}</div>}\n      bodyContent={<div>{description}</div>}\n    >\n      <OutlinedQuestionCircleIcon />\n    </Popover>\n  );\n};\n","import React, { useState, useEffect, useRef } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Configuration, DefaultApi } from '@rhoas/kafka-management-sdk';\nimport { useAlert, useAuth, useConfig } from '@rhoas/app-services-ui-shared';\nimport { isServiceApiError } from '@app/utils';\nimport {\n  AlertVariant,\n  Bullseye,\n  Card,\n  CardTitle,\n  CardBody,\n  Spinner,\n} from '@patternfly/react-core';\nimport {\n  Chart,\n  ChartArea,\n  ChartAxis,\n  ChartGroup,\n  ChartLegend,\n  ChartThemeColor,\n  ChartThreshold,\n  ChartVoronoiContainer,\n} from '@patternfly/react-charts';\nimport chart_color_blue_300 from '@patternfly/react-tokens/dist/js/chart_color_blue_300';\nimport chart_color_black_500 from '@patternfly/react-tokens/dist/js/chart_color_black_500';\nimport { ChartEmptyState, ChartToolbar } from '@app/modules/Metrics/components';\nimport { convertToSpecifiedByte } from '@app/modules/Metrics/utils';\nimport { ChartPopover } from '../ChartPopover';\n\ntype Broker = {\n  name: string;\n  data: {\n    timestamp: number;\n    usedSpaceAvg: number[];\n  }[];\n};\n\ntype ChartData = {\n  areaColor: string;\n  softLimitColor: string;\n  area: BrokerChartData[];\n  softLimit: BrokerChartData[];\n};\n\ntype BrokerChartData = {\n  name: string;\n  x: string;\n  y: number;\n};\n\ntype LegendData = {\n  name: string;\n  symbol: any;\n};\n\ntype KafkaInstanceProps = {\n  kafkaID: string;\n  metricsDataUnavailable: boolean;\n  setMetricsDataUnavailable: (value: boolean) => void;\n};\n\nexport const UsedDiskSpaceChart: React.FC<KafkaInstanceProps> = ({\n  kafkaID,\n  metricsDataUnavailable,\n  setMetricsDataUnavailable,\n}: KafkaInstanceProps) => {\n  const containerRef = useRef();\n  const { t } = useTranslation();\n  const auth = useAuth();\n  const { kas } = useConfig() || {};\n  const { apiBasePath: basePath } = kas || {};\n  const { addAlert } = useAlert() || {};\n  const [width, setWidth] = useState();\n  const [legend, setLegend] = useState();\n  const [chartData, setChartData] = useState<ChartData[]>();\n  const [chartDataLoading, setChartDataLoading] = useState(true);\n  const [largestByteSize, setLargestByteSize] = useState();\n  const [timeDuration, setTimeDuration] = useState(6);\n  const [timeInterval, setTimeInterval] = useState(60);\n  const usageLimit = 60; // Replace with limit from API\n\n  const handleResize = () =>\n    containerRef.current && setWidth(containerRef.current.clientWidth);\n  const itemsPerRow = width && width > 650 ? 6 : 3;\n\n  const fetchUsedDiskSpaceMetrics = async () => {\n    const accessToken = await auth?.kas.getToken();\n    if (accessToken !== undefined && accessToken !== '') {\n      try {\n        const apisService = new DefaultApi(\n          new Configuration({\n            accessToken,\n            basePath,\n          })\n        );\n        if (!kafkaID) {\n          return;\n        }\n\n        const data = await apisService.getMetricsByRangeQuery(\n          kafkaID,\n          timeDuration * 60,\n          timeInterval * 60,\n          ['kubelet_volume_stats_used_bytes']\n        );\n\n        const avgBroker = {\n          name: `Used disk space`,\n          data: [],\n        } as Broker;\n\n        if (data.data.items) {\n          setMetricsDataUnavailable(false);\n          data.data.items?.forEach((item, index) => {\n            const labels = item.metric;\n\n            if (labels === undefined) {\n              throw new Error('item.metric cannot be undefined');\n            }\n            if (item.values === undefined) {\n              throw new Error('item.values cannot be undefined');\n            }\n            if (labels['__name__'] === 'kubelet_volume_stats_used_bytes') {\n              const pvcName = labels['persistentvolumeclaim'];\n\n              if (!pvcName.includes('zookeeper')) {\n                item.values?.forEach((value, indexJ) => {\n                  if (value.timestamp == undefined) {\n                    throw new Error('timestamp cannot be undefined');\n                  }\n\n                  if (index > 0) {\n                    const newArray = avgBroker.data[indexJ].usedSpaceAvg.concat(\n                      value.value\n                    );\n                    avgBroker.data[indexJ].usedSpaceAvg = newArray;\n                  } else {\n                    avgBroker.data.push({\n                      timestamp: value.timestamp,\n                      usedSpaceAvg: [value.value],\n                    });\n                  }\n                });\n              }\n            }\n\n            getChartData(avgBroker);\n          });\n        } else {\n          setMetricsDataUnavailable(true);\n          setChartDataLoading(false);\n        }\n      } catch (error) {\n        let reason: string | undefined;\n        if (isServiceApiError(error)) {\n          reason = error.response?.data.reason;\n        }\n        addAlert &&\n          addAlert({\n            variant: AlertVariant.danger,\n            title: t('common.something_went_wrong'),\n            description: reason,\n          });\n      }\n    }\n  };\n\n  useEffect(() => {\n    fetchUsedDiskSpaceMetrics();\n    handleResize();\n  }, [timeDuration, timeInterval]);\n\n  // useTimeout(() => fetchUsedDiskSpaceMetrics(), 1000 * 60 * 5);\n\n  useEffect(() => {\n    handleResize();\n    window.addEventListener('resize', handleResize);\n  }, [width]);\n\n  const getChartData = (avgBroker) => {\n    const legendData: Array<LegendData> = [\n      {\n        name: 'Limit',\n        symbol: { fill: chart_color_black_500.value, type: 'threshold' },\n      },\n      { name: avgBroker.name, symbol: { fill: chart_color_blue_300.value } },\n    ];\n\n    const areaColor = chart_color_blue_300.value;\n    const softLimitColor = chart_color_black_500.value;\n    const chartData: Array<ChartData> = [];\n    const area: Array<BrokerChartData> = [];\n    const softLimit: Array<BrokerChartData> = [];\n    const largestByteSize = 'GiB'; // Hard code GiB as the largest byte size because there will always be a 20 GiB limit.\n\n    const getCurrentLengthOfData = () => {\n      const timestampDiff =\n        avgBroker.data[avgBroker.data.length - 1].timestamp -\n        avgBroker.data[0].timestamp;\n      const minutes = timestampDiff / 1000 / 60;\n      return minutes;\n    };\n\n    const lengthOfData = 6 * 60 - getCurrentLengthOfData();\n    const lengthOfDataPer5Mins = (6 * 60 - getCurrentLengthOfData()) / 5;\n\n    if (lengthOfData <= 360 && timeDuration >= 6) {\n      for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n        const newTimestamp =\n          avgBroker.data[0].timestamp -\n          (lengthOfDataPer5Mins - i) * (5 * 60000);\n        const date = new Date(newTimestamp);\n        const time = date.getHours() + ':' + date.getMinutes();\n        area.push({ name: avgBroker.name, x: time, y: 0 });\n        softLimit.push({ name: 'Limit', x: time, y: usageLimit });\n      }\n    }\n\n    avgBroker.data.map((value) => {\n      const date = new Date(value.timestamp);\n      const time = date.getHours() + ':' + date.getMinutes();\n      const aggregateBytes = value.usedSpaceAvg.reduce(function (a, b) {\n        return a + b;\n      }, 0);\n\n      const bytes = convertToSpecifiedByte(aggregateBytes, largestByteSize);\n      area.push({ name: avgBroker.name, x: time, y: bytes });\n      softLimit.push({ name: 'Limit', x: time, y: usageLimit });\n    });\n    chartData.push({ areaColor, softLimitColor, area, softLimit });\n\n    setLegend(legendData);\n    setChartData(chartData);\n    setLargestByteSize(largestByteSize);\n    setChartDataLoading(false);\n  };\n\n  const onRefreshKafkaToolbar = () => {\n    fetchUsedDiskSpaceMetrics();\n  };\n\n  return (\n    <Card>\n      <ChartToolbar\n        showTopicFilter={false}\n        title={t('metrics.kafka_instance_metrics')}\n        setTimeDuration={setTimeDuration}\n        setTimeInterval={setTimeInterval}\n        showKafkaToolbar={!metricsDataUnavailable}\n        onRefreshKafkaToolbar={onRefreshKafkaToolbar}\n      />\n      <CardTitle component='h2'>\n        {t('metrics.used_disk_space')}{' '}\n        <ChartPopover\n          title={t('metrics.used_disk_space')}\n          description={t('metrics.used_disk_space_help_text')}\n        />\n      </CardTitle>\n      <CardBody>\n        <div ref={containerRef}>\n          {!chartDataLoading ? (\n            !metricsDataUnavailable ? (\n              chartData &&\n              legend &&\n              largestByteSize && (\n                <Chart\n                  ariaTitle={t('metrics.used_disk_space')}\n                  containerComponent={\n                    <ChartVoronoiContainer\n                      labels={({ datum }) => `${datum.name}: ${datum.y}`}\n                      constrainToVisibleArea\n                    />\n                  }\n                  legendPosition='bottom-left'\n                  legendComponent={\n                    <ChartLegend\n                      orientation={'horizontal'}\n                      data={legend}\n                      itemsPerRow={itemsPerRow}\n                    />\n                  }\n                  height={350}\n                  padding={{\n                    bottom: 110, // Adjusted to accomodate legend\n                    left: 90,\n                    right: 60,\n                    top: 25,\n                  }}\n                  themeColor={ChartThemeColor.multiUnordered}\n                  width={width}\n                  minDomain={{ y: 0 }}\n                  legendAllowWrap={true}\n                >\n                  <ChartAxis label={'Time'} tickCount={6} />\n                  <ChartAxis\n                    dependentAxis\n                    tickFormat={(t) => `${Math.round(t)} ${largestByteSize}`}\n                    tickCount={4}\n                  />\n                  <ChartGroup>\n                    {chartData.map((value, index) => (\n                      <ChartArea\n                        key={`chart-area-${index}`}\n                        data={value.area}\n                        interpolation='monotoneX'\n                        style={{\n                          data: {\n                            stroke: value.color,\n                          },\n                        }}\n                      />\n                    ))}\n                  </ChartGroup>\n                  <ChartThreshold\n                    key={`chart-softlimit`}\n                    data={chartData[0].softLimit}\n                    style={{\n                      data: {\n                        stroke: chartData[0].softLimitColor,\n                      },\n                    }}\n                  />\n                </Chart>\n              )\n            ) : (\n              <ChartEmptyState\n                title={t('metrics.empty_state_no_data_title')}\n                body={t('metrics.empty_state_no_data_body')}\n                noData\n              />\n            )\n          ) : (\n            <Bullseye>\n              <Spinner isSVG />\n            </Bullseye>\n          )}\n        </div>\n      </CardBody>\n    </Card>\n  );\n};\n","import React from 'react';\nimport {\n  Chart,\n  ChartAxis,\n  ChartGroup,\n  ChartLine,\n  ChartThemeColor,\n  ChartLegendTooltip,\n  createContainer,\n} from '@patternfly/react-charts';\nimport { format } from 'date-fns';\n\nexport type Topic = {\n  name: string;\n\n  data: {\n    timestamp: number;\n    count: number;\n  }[];\n};\n\nexport type MessagesChartProps = {\n  topics: Topic[];\n};\n\nexport class MessagesChart extends React.Component<MessagesChartProps> {\n  render() {\n    // Note: Container order is important\n    const CursorVoronoiContainer = createContainer('voronoi', 'cursor');\n\n    const legendData = [] as any[];\n    const chartData = [] as any[];\n\n    this.props.topics.forEach((topic) => {\n      legendData.push({ name: topic.name });\n\n      const messages = topic.data.map((value) => {\n        const date = new Date(value.timestamp);\n        const time = date.getHours() + ':' + date.getMinutes();\n        return {\n          x: time,\n          y: value.count,\n          name: topic.name,\n        };\n      });\n      chartData.push(messages);\n    });\n\n    return (\n      <div style={{ height: '300x', width: '450px' }}>\n        <Chart\n          ariaTitle='Messages in to a topic'\n          containerComponent={\n            <CursorVoronoiContainer\n              cursorDimension='x'\n              labels={({ datum }) => `${datum.y}`}\n              labelComponent={\n                <ChartLegendTooltip\n                  legendData={legendData}\n                  title={(datum) => datum.x}\n                />\n              }\n              mouseFollowTooltips\n              voronoiDimension='x'\n              voronoiPadding={50}\n            />\n          }\n          legendData={legendData}\n          legendPosition='bottom'\n          height={300}\n          maxDomain={{ y: 10 }}\n          minDomain={{ y: 0 }}\n          padding={{\n            bottom: 100, // Adjusted to accommodate legend\n            left: 70,\n            right: 50,\n            top: 50,\n          }}\n          themeColor={ChartThemeColor.green}\n          width={450}\n        >\n          <ChartAxis label='time' tickCount={6} />\n          <ChartAxis dependentAxis showGrid label={'messages'} />\n          <ChartGroup>\n            {chartData.map((value, index) => (\n              <ChartLine data={value} key={`chart-messages-${index}`} />\n            ))}\n          </ChartGroup>\n        </Chart>\n      </div>\n    );\n  }\n}\n","import React, { useState, useEffect, useRef } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Configuration, DefaultApi } from '@rhoas/kafka-management-sdk';\nimport { useAlert, useAuth, useConfig } from '@rhoas/app-services-ui-shared';\nimport { isServiceApiError } from '@app/utils';\nimport { AlertVariant, Divider } from '@patternfly/react-core';\nimport chart_color_blue_300 from '@patternfly/react-tokens/dist/js/chart_color_blue_300';\nimport chart_color_orange_300 from '@patternfly/react-tokens/dist/js/chart_color_orange_300';\nimport {\n  getLargestByteSize,\n  convertToSpecifiedByte,\n} from '@app/modules/Metrics/utils';\nimport {\n  Bullseye,\n  Card,\n  CardTitle,\n  CardBody,\n  Spinner,\n} from '@patternfly/react-core';\nimport {\n  Chart,\n  ChartLine,\n  ChartAxis,\n  ChartGroup,\n  ChartLegend,\n  ChartThemeColor,\n  ChartVoronoiContainer,\n} from '@patternfly/react-charts';\nimport {\n  ChartEmptyState,\n  ChartPopover,\n  ChartToolbar,\n  LogSizePerPartitionChart,\n} from '@app/modules/Metrics/components';\n\ntype Topic = {\n  name: string;\n  rawData: Map<number, number[]>;\n  sortedData: TopicDataArray;\n};\n\ntype TopicDataArray = { timestamp: number; bytes: number[] }[];\n\ntype ChartData = {\n  color: string;\n  line: TopicChartData[];\n};\n\ntype TopicChartData = {\n  name: string;\n  x: string;\n  y: number;\n};\n\ntype LegendData = {\n  name: string;\n  symbol: any;\n};\n\ntype KafkaInstanceProps = {\n  kafkaID: string;\n  metricsDataUnavailable: boolean;\n  setMetricsDataUnavailable: (value: boolean) => void;\n  onCreateTopic: () => void;\n};\n\nexport const IncomingOutgoingBytesPerTopic: React.FC<KafkaInstanceProps> = ({\n  kafkaID,\n  metricsDataUnavailable,\n  setMetricsDataUnavailable,\n  onCreateTopic,\n}: KafkaInstanceProps) => {\n  const { t } = useTranslation();\n  const auth = useAuth();\n  const { kas } = useConfig() || {};\n  const { apiBasePath: basePath } = kas || {};\n  const { addAlert } = useAlert() || {};\n  const containerRef = useRef();\n  const [width, setWidth] = useState();\n  const [timeDuration, setTimeDuration] = useState(6);\n  const [timeInterval, setTimeInterval] = useState(60);\n  const [selectedTopic, setSelectedTopic] = useState<boolean | string>(false);\n  const [isFilterApplied, setIsFilterApplied] = useState<boolean>(false);\n\n  const handleResize = () =>\n    containerRef.current && setWidth(containerRef.current.clientWidth);\n  const itemsPerRow = width && width > 650 ? 6 : 3;\n\n  useEffect(() => {\n    handleResize();\n    window.addEventListener('resize', handleResize);\n  }, [width]);\n\n  const [chartData, setChartData] = useState<ChartData[]>();\n  const [legend, setLegend] = useState<LegendData[]>();\n  const [largestByteSize, setLargestByteSize] = useState();\n  const [noTopics, setNoTopics] = useState<boolean>();\n  const [chartDataLoading, setChartDataLoading] = useState(true);\n  const [topicList, setTopicList] = useState<string[]>([]);\n\n  const fetchBytesData = async () => {\n    const accessToken = await auth?.kas.getToken();\n    if (accessToken !== undefined && accessToken !== '') {\n      try {\n        const apisService = new DefaultApi(\n          new Configuration({\n            accessToken,\n            basePath,\n          })\n        );\n\n        if (!kafkaID) {\n          return;\n        }\n        const data = await apisService.getMetricsByRangeQuery(\n          kafkaID,\n          timeDuration * 60,\n          timeInterval * 60,\n          [\n            'kafka_server_brokertopicmetrics_bytes_in_total',\n            'kafka_server_brokertopicmetrics_bytes_out_total',\n          ]\n        );\n\n        const incomingTopics = {\n          name: 'Total incoming bytes',\n          rawData: new Map<number, number[]>(),\n        } as Topic;\n\n        const outgoingTopics = {\n          name: 'Total outgoing bytes',\n          rawData: new Map<number, number[]>(),\n        } as Topic;\n\n        if (data.data.items) {\n          setMetricsDataUnavailable(false);\n\n          data.data.items?.forEach((item, index) => {\n            const labels = item.metric;\n            if (labels === undefined) {\n              throw new Error('item.metric cannot be undefined');\n            }\n            if (item.values === undefined) {\n              throw new Error('item.values cannot be undefined');\n            }\n\n            if (\n              labels['topic'] !== '__strimzi_canary' &&\n              labels['topic'] !== '__consumer_offsets'\n            ) {\n              topicList &&\n                labels['topic'] &&\n                topicList.indexOf(labels['topic']) === -1 &&\n                setTopicList([...topicList, labels['topic']]);\n            }\n\n            const isSelectedItem = isFilterApplied\n              ? labels['topic'] !== '__strimzi_canary' &&\n                labels['topic'] !== '__consumer_offsets' &&\n                selectedTopic === labels['topic']\n              : labels['topic'] !== '__strimzi_canary' &&\n                labels['topic'] !== '__consumer_offsets';\n\n            if (isSelectedItem) {\n              if (\n                labels['__name__'] ===\n                'kafka_server_brokertopicmetrics_bytes_in_total'\n              ) {\n                item.values?.forEach((value, indexJ) => {\n                  if (value.timestamp == undefined) {\n                    throw new Error('timestamp cannot be undefined');\n                  }\n                  if (incomingTopics.rawData.has(value.timestamp)) {\n                    incomingTopics.rawData\n                      .get(value.timestamp)\n                      ?.push(value.value);\n                  } else {\n                    incomingTopics.rawData.set(value.timestamp, [\n                      value.value,\n                    ] as number[]);\n                  }\n                });\n              }\n              if (\n                labels['__name__'] ===\n                'kafka_server_brokertopicmetrics_bytes_out_total'\n              ) {\n                item.values?.forEach((value, indexJ) => {\n                  if (value.timestamp == undefined) {\n                    throw new Error('timestamp cannot be undefined');\n                  }\n                  if (outgoingTopics.rawData.has(value.timestamp)) {\n                    outgoingTopics.rawData\n                      .get(value.timestamp)\n                      ?.push(value.value);\n                  } else {\n                    outgoingTopics.rawData.set(value.timestamp, [\n                      value.value,\n                    ] as number[]);\n                  }\n                });\n              }\n            }\n          });\n\n          if (\n            incomingTopics.rawData.size < 1 &&\n            outgoingTopics.rawData.size < 1\n          ) {\n            setNoTopics(true);\n            setChartDataLoading(false);\n          } else {\n            const incomingDataArr = [] as TopicDataArray;\n            incomingTopics.rawData.forEach((value, key) =>\n              incomingDataArr.push({ timestamp: key, bytes: value })\n            );\n            incomingTopics.sortedData = incomingDataArr.sort(\n              (a, b) => a.timestamp - b.timestamp\n            );\n            const outgoingDataArr = [] as TopicDataArray;\n            outgoingTopics.rawData.forEach((value, key) =>\n              outgoingDataArr.push({ timestamp: key, bytes: value })\n            );\n            outgoingTopics.sortedData = outgoingDataArr.sort(\n              (a, b) => a.timestamp - b.timestamp\n            );\n            getChartData(incomingTopics, outgoingTopics);\n          }\n        } else {\n          setMetricsDataUnavailable(true);\n          setChartDataLoading(false);\n        }\n      } catch (error) {\n        let reason: string | undefined;\n        if (isServiceApiError(error)) {\n          reason = error.response?.data.reason;\n        }\n        addAlert &&\n          addAlert({\n            variant: AlertVariant.danger,\n            title: t('common.something_went_wrong'),\n            description: reason,\n          });\n      }\n    }\n  };\n\n  useEffect(() => {\n    fetchBytesData();\n  }, [timeDuration, timeInterval]);\n\n  // useTimeout(() => fetchBytesData(), 1000 * 60 * 5);\n\n  const getChartData = (\n    incomingTopicArray: Topic,\n    outgoingTopicArray: Topic\n  ) => {\n    const legendData: Array<LegendData> = [];\n    const chartData: Array<ChartData> = [];\n    const largestByteSize = getLargestByteSize(\n      incomingTopicArray,\n      outgoingTopicArray\n    );\n\n    // Aggregate of Incoming Bytes per Topic\n    if (incomingTopicArray) {\n      const line: Array<TopicChartData> = [];\n      const color = chart_color_blue_300.value;\n\n      const getCurrentLengthOfData = () => {\n        const timestampDiff =\n          incomingTopicArray.sortedData[\n            incomingTopicArray.sortedData.length - 1\n          ].timestamp - incomingTopicArray.sortedData[0].timestamp;\n        const minutes = timestampDiff / 1000 / 60;\n        return minutes;\n      };\n      const lengthOfData = 6 * 60 - getCurrentLengthOfData();\n      const lengthOfDataPer5Mins = (6 * 60 - getCurrentLengthOfData()) / 5;\n\n      if (lengthOfData <= 360 && timeDuration >= 6) {\n        for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n          const newTimestamp =\n            incomingTopicArray.sortedData[0].timestamp -\n            (lengthOfDataPer5Mins - i) * (5 * 60000);\n          const date = new Date(newTimestamp);\n          const time = date.getHours() + ':' + date.getMinutes();\n          line.push({ name: incomingTopicArray.name, x: time, y: 0 });\n        }\n      }\n\n      incomingTopicArray.sortedData.map((value) => {\n        const date = new Date(value.timestamp);\n        const time = date.getHours() + ':' + date.getMinutes();\n\n        const aggregateBytes = value.bytes.reduce(function (a, b) {\n          return a + b;\n        }, 0);\n        const bytes = convertToSpecifiedByte(aggregateBytes, largestByteSize);\n        line.push({ name: incomingTopicArray.name, x: time, y: bytes });\n      });\n\n      chartData.push({ color, line });\n\n      legendData.push({\n        name: incomingTopicArray.name,\n        symbol: {\n          fill: chart_color_blue_300.value,\n        },\n      });\n    }\n\n    // Aggregate of Outgoing Bytes per Topic\n    if (outgoingTopicArray) {\n      const line: Array<TopicChartData> = [];\n      const color = chart_color_orange_300.value;\n\n      const getCurrentLengthOfData = () => {\n        const timestampDiff =\n          outgoingTopicArray.sortedData[\n            outgoingTopicArray.sortedData.length - 1\n          ].timestamp - outgoingTopicArray.sortedData[0].timestamp;\n        const minutes = timestampDiff / 1000 / 60;\n        return minutes;\n      };\n      const lengthOfData = 6 * 60 - getCurrentLengthOfData();\n      const lengthOfDataPer5Mins = (6 * 60 - getCurrentLengthOfData()) / 5;\n\n      if (lengthOfData <= 360 && timeDuration >= 6) {\n        for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n          const newTimestamp =\n            outgoingTopicArray.sortedData[0].timestamp -\n            (lengthOfDataPer5Mins - i) * (5 * 60000);\n          const date = new Date(newTimestamp);\n          const time = date.getHours() + ':' + date.getMinutes();\n          line.push({ name: outgoingTopicArray.name, x: time, y: 0 });\n        }\n      }\n\n      outgoingTopicArray.sortedData.map((value) => {\n        const date = new Date(value.timestamp);\n        const time = date.getHours() + ':' + date.getMinutes();\n\n        const aggregateBytes = value.bytes.reduce(function (a, b) {\n          return a + b;\n        }, 0);\n        const bytes = convertToSpecifiedByte(aggregateBytes, largestByteSize);\n        line.push({ name: outgoingTopicArray.name, x: time, y: bytes });\n      });\n      chartData.push({ color, line });\n      legendData.push({\n        name: outgoingTopicArray.name,\n        symbol: {\n          fill: chart_color_orange_300.value,\n        },\n      });\n    }\n    setLegend(legendData);\n    setChartData(chartData);\n    setLargestByteSize(largestByteSize);\n    setChartDataLoading(false);\n  };\n\n  const onRefreshTopicToolbar = () => {\n    fetchBytesData();\n  };\n\n  return (\n    <Card>\n      <ChartToolbar\n        showTopicFilter={true}\n        title={t('metrics.topic_metrics')}\n        setTimeDuration={setTimeDuration}\n        setTimeInterval={setTimeInterval}\n        showTopicToolbar={!noTopics && !metricsDataUnavailable}\n        selectedTopic={selectedTopic}\n        setSelectedTopic={setSelectedTopic}\n        onRefreshTopicToolbar={onRefreshTopicToolbar}\n        topicList={topicList}\n        setIsFilterApplied={setIsFilterApplied}\n      />\n      <CardTitle component='h2'>\n        {t('metrics.total_bytes')}{' '}\n        <ChartPopover\n          title={t('metrics.total_bytes')}\n          description={t('metrics.topic_metrics_help_text')}\n        />\n      </CardTitle>\n      <CardBody>\n        <div ref={containerRef}>\n          <div>\n            {!chartDataLoading ? (\n              !metricsDataUnavailable ? (\n                !noTopics ? (\n                  chartData &&\n                  legend &&\n                  largestByteSize && (\n                    <>\n                      <Chart\n                        ariaTitle={t('metrics.total_bytes')}\n                        containerComponent={\n                          <ChartVoronoiContainer\n                            labels={({ datum }) => `${datum.name}: ${datum.y}`}\n                            constrainToVisibleArea\n                          />\n                        }\n                        legendAllowWrap={true}\n                        legendPosition='bottom-left'\n                        legendComponent={\n                          <ChartLegend\n                            data={legend}\n                            itemsPerRow={itemsPerRow}\n                          />\n                        }\n                        height={300}\n                        padding={{\n                          bottom: 110,\n                          left: 90,\n                          right: 30,\n                          top: 25,\n                        }}\n                        themeColor={ChartThemeColor.multiUnordered}\n                        width={width}\n                      >\n                        <ChartAxis label={'Time'} tickCount={6} />\n                        <ChartAxis\n                          dependentAxis\n                          tickFormat={(t) =>\n                            `${Math.round(t)} ${largestByteSize}`\n                          }\n                          tickCount={4}\n                          minDomain={{ y: 0 }}\n                        />\n                        <ChartGroup>\n                          {chartData.map((value, index) => (\n                            <ChartLine\n                              key={`chart-line-${index}`}\n                              data={value.line}\n                              style={{\n                                data: {\n                                  stroke: value.color,\n                                },\n                              }}\n                            />\n                          ))}\n                        </ChartGroup>\n                      </Chart>\n\n                      <Divider />\n                      {selectedTopic ? (\n                        <LogSizePerPartitionChart\n                          kafkaID={kafkaID}\n                          timeDuration={timeDuration}\n                          timeInterval={timeInterval}\n                        />\n                      ) : (\n                        <Card>\n                          <CardTitle component='h2'>\n                            {t('metrics.topic_partition_size')}\n                          </CardTitle>\n                          <CardBody>\n                            <ChartEmptyState\n                              title={t('metrics.empty_state_no_filter_title')}\n                              body={t('metrics.empty_state_no_filter_body')}\n                              noFilter\n                            />{' '}\n                          </CardBody>\n                        </Card>\n                      )}\n                    </>\n                  )\n                ) : (\n                  <ChartEmptyState\n                    title={t('metrics.empty_state_no_topics_title')}\n                    body={t('metrics.empty_state_no_topics_body')}\n                    noTopics\n                    onCreateTopic={onCreateTopic}\n                  />\n                )\n              ) : (\n                <ChartEmptyState\n                  title={t('metrics.empty_state_no_data_title')}\n                  body={t('metrics.empty_state_no_data_body')}\n                  noData\n                />\n              )\n            ) : (\n              <Bullseye>\n                <Spinner isSVG />\n              </Bullseye>\n            )}\n          </div>\n        </div>\n      </CardBody>\n    </Card>\n  );\n};\n","import React, { useState, useEffect, useRef } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Configuration, DefaultApi } from '@rhoas/kafka-management-sdk';\nimport { useAlert, useAuth, useConfig } from '@rhoas/app-services-ui-shared';\nimport { isServiceApiError } from '@app/utils';\nimport {\n  AlertVariant,\n  Bullseye,\n  Card,\n  CardTitle,\n  CardBody,\n  Spinner,\n} from '@patternfly/react-core';\nimport {\n  Chart,\n  ChartArea,\n  ChartAxis,\n  ChartGroup,\n  ChartLegend,\n  ChartThemeColor,\n  ChartVoronoiContainer,\n} from '@patternfly/react-charts';\nimport chart_color_blue_300 from '@patternfly/react-tokens/dist/js/chart_color_blue_300';\nimport chart_color_green_300 from '@patternfly/react-tokens/dist/js/chart_color_green_300';\nimport byteSize from 'byte-size';\nimport { ChartEmptyState, ChartPopover } from '@app/modules/Metrics/components';\nimport {\n  getLargestByteSize,\n  convertToSpecifiedByte,\n} from '@app/modules/Metrics/utils';\n\nexport type Partition = {\n  name: string;\n  data: {\n    timestamp: number;\n    bytes: number;\n    name: string;\n  }[];\n};\n\nexport type ChartData = {\n  color: string;\n  area: PartitionChartData[];\n};\n\nexport type PartitionChartData = {\n  name: string;\n  x: string;\n  y: number;\n};\n\nexport type LegendData = {\n  name: string;\n};\n\nexport type KafkaInstanceProps = {\n  kafkaID: string;\n  timeInterval: number;\n  timeDuration: number;\n};\n\nexport const LogSizePerPartitionChart: React.FC<KafkaInstanceProps> = ({\n  kafkaID,\n  timeDuration,\n  timeInterval,\n}: KafkaInstanceProps) => {\n  const containerRef = useRef();\n  const { t } = useTranslation();\n  const auth = useAuth();\n  const {\n    kas: { apiBasePath: basePath },\n  } = useConfig();\n  const { addAlert } = useAlert();\n  const [width, setWidth] = useState<number>();\n  const [legend, setLegend] = useState();\n  const [chartData, setChartData] = useState<ChartData[]>();\n  const [largestByteSize, setLargestByteSize] = useState();\n  const [metricsDataUnavailable, setMetricsDataUnavailable] = useState(false);\n  const [chartDataLoading, setChartDataLoading] = useState(true);\n  const [noTopics, setNoTopics] = useState<boolean>();\n\n  const colors = [chart_color_green_300.value, chart_color_blue_300.value];\n\n  const handleResize = () =>\n    containerRef.current && setWidth(containerRef.current.clientWidth);\n  const itemsPerRow = width && width > 650 ? 6 : 3;\n\n  // Functions\n  const fetchLogSizePerPartition = async () => {\n    const accessToken = await auth?.kas.getToken();\n    if (accessToken !== undefined && accessToken !== '') {\n      try {\n        const apisService = new DefaultApi(\n          new Configuration({\n            accessToken,\n            basePath,\n          })\n        );\n        if (!kafkaID) {\n          return;\n        }\n        const data = await apisService.getMetricsByRangeQuery(\n          kafkaID,\n          timeDuration * 60,\n          timeInterval * 60,\n          ['kafka_log_log_size']\n        );\n\n        const partitionArray: Partition[] = [];\n\n        if (data.data.items) {\n          setMetricsDataUnavailable(false);\n          data.data.items?.forEach((item, i) => {\n            const topicName = item?.metric?.topic;\n            const labels = item.metric;\n            if (item.metric === undefined) {\n              throw new Error('item.metric cannot be undefined');\n            }\n            if (item.values === undefined) {\n              throw new Error('item.values cannot be undefined');\n            }\n\n            const topic = {\n              name: topicName,\n              data: [],\n            } as Partition;\n\n            const isTopicInArray = partitionArray.some(\n              (topic) => topic.name === topicName\n            );\n\n            if (labels['__name__'] === 'kafka_topic:kafka_log_log_size:sum') {\n              item.values?.forEach((value) => {\n                if (value.timestamp == undefined) {\n                  throw new Error('timestamp cannot be undefined');\n                }\n\n                if (isTopicInArray) {\n                  partitionArray.forEach((topic: Partition) => {\n                    if (topic.name === topicName) {\n                      topic.data.forEach(\n                        (datum) => (datum.bytes = datum.bytes + value.value)\n                      );\n                    }\n                  });\n                } else {\n                  topic.data.push({\n                    name: topicName || '',\n                    timestamp: value.timestamp,\n                    bytes: value.value,\n                  });\n                }\n              });\n            }\n\n            if (!isTopicInArray) {\n              partitionArray.push(topic);\n            }\n          });\n          // Check if atleast one topic exists that isn't Strimzi Canary or Consumer Offsets - Keep this here for testing purposes\n          const filteredTopics = partitionArray.filter(\n            (topic) =>\n              topic.name !== '__strimzi_canary' &&\n              topic.name !== '__consumer_offsets'\n          );\n\n          if (filteredTopics.length < 1) {\n            setNoTopics(true);\n          }\n          getChartData(filteredTopics);\n        } else {\n          setMetricsDataUnavailable(true);\n          setChartDataLoading(false);\n        }\n      } catch (error) {\n        let reason: string | undefined;\n        if (isServiceApiError(error)) {\n          reason = error.response?.data.reason;\n        }\n        addAlert({\n          variant: AlertVariant.danger,\n          title: t('common.something_went_wrong'),\n          description: reason,\n        });\n      }\n    }\n  };\n\n  useEffect(() => {\n    fetchLogSizePerPartition();\n    handleResize();\n  }, [timeInterval, timeDuration]);\n\n  // useTimeout(() => fetchLogSizePerPartition(), 1000 * 60 * 5);\n\n  useEffect(() => {\n    handleResize();\n    window.addEventListener('resize', handleResize);\n  }, [width]);\n\n  const getChartData = (partitionArray) => {\n    const legendData: Array<LegendData> = [];\n    const chartData: Array<ChartData> = [];\n    const largestByteSize = getLargestByteSize(partitionArray, undefined);\n    partitionArray.map((partition, index) => {\n      const color = colors[index];\n      legendData.push({\n        name: partition.name,\n      });\n      const area: Array<PartitionChartData> = [];\n\n      const getCurrentLengthOfData = () => {\n        const timestampDiff =\n          partition.data[partition.data.length - 1].timestamp -\n          partition.data[0].timestamp;\n        const minutes = timestampDiff / 1000 / 60;\n        return minutes;\n      };\n      const lengthOfData = 6 * 60 - getCurrentLengthOfData();\n      const lengthOfDataPer5Mins = (6 * 60 - getCurrentLengthOfData()) / 5;\n\n      if (lengthOfData <= 360 && timeDuration >= 6) {\n        for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n          const newtimestamp =\n            partition.data[0].timestamp -\n            (lengthOfDataPer5Mins - i) * (5 * 60000);\n          const date = new Date(newtimestamp);\n          const time = date.getHours() + ':' + date.getMinutes();\n          area.push({ name: partition.name, x: time, y: 0 });\n        }\n      }\n\n      partition.data.map((value) => {\n        const date = new Date(value.timestamp);\n        const time = date.getHours() + ':' + date.getMinutes();\n        const bytes = convertToSpecifiedByte(value.bytes, largestByteSize);\n        area.push({ name: value.name, x: time, y: bytes });\n      });\n      chartData.push({ color, area });\n    });\n    setLegend(legendData);\n    setChartData(chartData);\n    setLargestByteSize(largestByteSize);\n    setChartDataLoading(false);\n  };\n\n  return (\n    <Card>\n      <CardTitle component='h2'>\n        {t('metrics.log_size_per_partition')}{' '}\n        <ChartPopover\n          title={t('metrics.log_size_per_partition')}\n          description={t('metrics.log_size_per_partition_help_text')}\n        />\n      </CardTitle>\n      <CardBody>\n        <div ref={containerRef}>\n          {!chartDataLoading ? (\n            !metricsDataUnavailable ? (\n              !noTopics ? (\n                chartData &&\n                legend &&\n                byteSize && (\n                  <Chart\n                    ariaTitle={t('metrics.log_size_per_partition')}\n                    containerComponent={\n                      <ChartVoronoiContainer\n                        labels={({ datum }) => `${datum.name}: ${datum.y}`}\n                        constrainToVisibleArea\n                      />\n                    }\n                    legendPosition='bottom-left'\n                    legendComponent={\n                      <ChartLegend data={legend} itemsPerRow={itemsPerRow} />\n                    }\n                    height={350}\n                    padding={{\n                      bottom: 110,\n                      left: 90,\n                      right: 30,\n                      top: 25,\n                    }}\n                    themeColor={ChartThemeColor.multiUnordered}\n                    width={width}\n                    legendAllowWrap={true}\n                  >\n                    <ChartAxis label={'Time'} tickCount={6} />\n                    <ChartAxis\n                      dependentAxis\n                      tickFormat={(t) => `${Math.round(t)} ${largestByteSize}`}\n                    />\n                    <ChartGroup>\n                      {chartData.map((value, index) => (\n                        <ChartArea\n                          key={`chart-area-${index}`}\n                          data={value.area}\n                          interpolation='monotoneX'\n                        />\n                      ))}\n                    </ChartGroup>\n                  </Chart>\n                )\n              ) : (\n                <ChartEmptyState\n                  title={t('metrics.empty_state_no_topics_title')}\n                  body={t('metrics.empty_state_no_topics_body')}\n                  noTopics\n                />\n              )\n            ) : (\n              <ChartEmptyState\n                title={t('metrics.empty_state_no_data_title')}\n                body={t('metrics.empty_state_no_data_body')}\n                noData\n              />\n            )\n          ) : (\n            <Bullseye>\n              <Spinner isSVG />\n            </Bullseye>\n          )}\n        </div>\n      </CardBody>\n    </Card>\n  );\n};\n","import React, { useEffect, useState } from 'react';\nimport {\n  ToolbarItem,\n  Select,\n  SelectVariant,\n  SelectGroup,\n  SelectOption,\n} from '@patternfly/react-core';\nimport FilterIcon from '@patternfly/react-icons/dist/js/icons/filter-icon';\n\ntype FilterByTopicProps = {\n  setSelectedTopic?: (value: string | boolean) => void;\n  selectedTopic?: string | boolean;\n  topicList?: string[];\n  setIsFilterApplied?: (value: boolean) => void;\n  disableToolbar: boolean;\n};\n\nexport const FilterByTopic = ({\n  selectedTopic,\n  setSelectedTopic,\n  topicList,\n  setIsFilterApplied,\n  disableToolbar,\n}: FilterByTopicProps) => {\n  const [isTopicSelectOpen, setIsTopicSelectOpen] = useState<boolean>(false);\n  const [topicListFinal, setTopicListFinal] = useState<string[]>();\n\n  useEffect(() => {\n    topicList && setTopicListFinal(topicList);\n  }, [topicList]);\n\n  const onTopicToggle = (isTopicSelectOpen) => {\n    setIsTopicSelectOpen(isTopicSelectOpen);\n  };\n\n  const onTopicSelect = (_, selection) => {\n    setSelectedTopic && setSelectedTopic(selection);\n    setIsFilterApplied &&\n      (selection !== 'All topics'\n        ? setIsFilterApplied(true)\n        : setIsFilterApplied(false));\n    setIsTopicSelectOpen(false);\n  };\n\n  const onTopicFilter = (_, textInput) => {\n    const filteredTopics =\n      topicListFinal?.filter((topic) => topic.indexOf(textInput) != -1) || [];\n    return topicOptions(filteredTopics);\n  };\n\n  const topicOptions = (topicList) => [\n    <SelectOption key={'topic-filter-0'} value='All topics' />,\n    <SelectGroup label='Filter by topic' key='topic-filter-group'>\n      {topicList?.map((topic, index) => (\n        <SelectOption key={`topic-filter-${index + 1}`} value={topic} />\n      ))}\n    </SelectGroup>,\n  ];\n\n  const widths = {\n    default: '100px',\n    sm: '80px',\n    md: '150px',\n    lg: '200px',\n    xl: '250px',\n    '2xl': '300px',\n  };\n\n  return (\n    <ToolbarItem widths={widths}>\n      <Select\n        variant={SelectVariant.single}\n        onToggle={onTopicToggle}\n        onSelect={onTopicSelect}\n        selections={selectedTopic}\n        isOpen={isTopicSelectOpen}\n        placeholderText={\n          <>\n            <FilterIcon /> All topics\n          </>\n        }\n        aria-labelledby={'titleId'}\n        onFilter={onTopicFilter}\n        isGrouped\n        hasInlineFilter\n        isDisabled={disableToolbar}\n        style={{ width: '100%' }}\n      >\n        {topicOptions(topicListFinal)}\n      </Select>\n    </ToolbarItem>\n  );\n};\n","import React, { useState } from 'react';\nimport {\n  ToolbarItem,\n  Select,\n  SelectVariant,\n  SelectGroup,\n  SelectOption,\n} from '@patternfly/react-core';\nimport { formatTime } from '../../utils';\n\ntype FilterByTimeProps = {\n  setTimeDuration: (value: number) => void;\n  setTimeInterval: (value: number) => void;\n  keyText: string;\n  disableToolbar: boolean;\n};\n\nexport const FilterByTime = ({\n  setTimeDuration,\n  setTimeInterval,\n  keyText,\n  disableToolbar,\n}: FilterByTimeProps) => {\n  const [selectedTime, setSelectedTime] = useState<boolean>(false);\n  const [isTimeSelectOpen, setIsTimeSelectOpen] = useState<boolean>(false);\n\n  const onTimeToggle = (isTimeSelectOpen) => {\n    setIsTimeSelectOpen(isTimeSelectOpen);\n  };\n\n  const onTimeSelect = (_, selection) => {\n    setTimeDuration(formatTime(selection).timeDuration);\n    setTimeInterval(formatTime(selection).timeInterval);\n    setSelectedTime(selection);\n    setIsTimeSelectOpen(false);\n  };\n\n  const timeOptions = (keyText: string) => [\n    <SelectGroup label='Relative time ranges' key={`${keyText}-group`}>\n      <SelectOption key={`${keyText}-0`} value='Last 5 minutes' />\n      <SelectOption key={`${keyText}-1`} value='Last 15 minutes' />\n      <SelectOption key={`${keyText}-2`} value='Last 30 minutes' />\n      <SelectOption key={`${keyText}-3`} value='Last 1 hour' />\n      <SelectOption key={`${keyText}-4`} value='Last 3 hours' />\n      <SelectOption key={`${keyText}-5`} value='Last 6 hours' />\n      <SelectOption key={`${keyText}-6`} value='Last 12 hours' />\n      <SelectOption key={`${keyText}-7`} value='Last 24 hours' />\n      <SelectOption key={`${keyText}-8`} value='Last 2 days' />\n      <SelectOption key={`${keyText}-9`} value='Last 7 days' />\n    </SelectGroup>,\n  ];\n  return (\n    <ToolbarItem>\n      <Select\n        variant={SelectVariant.single}\n        aria-label='Select Input'\n        onToggle={onTimeToggle}\n        onSelect={onTimeSelect}\n        selections={selectedTime}\n        isOpen={isTimeSelectOpen}\n        isDisabled={disableToolbar}\n        placeholderText='Last 6 hours'\n      >\n        {timeOptions(keyText)}\n      </Select>\n    </ToolbarItem>\n  );\n};\n","import React from 'react';\nimport {\n  Button,\n  CardTitle,\n  Divider,\n  Level,\n  LevelItem,\n  Toolbar,\n  ToolbarContent,\n} from '@patternfly/react-core';\nimport SyncIcon from '@patternfly/react-icons/dist/js/icons/sync-icon';\nimport { FilterByTopic } from './FilterByTopic';\nimport { FilterByTime } from './FilterByTime';\n\ntype ChartToolbarProps = {\n  title: string;\n  showTopicFilter: boolean;\n  setTimeDuration: (value: number) => void;\n  setTimeInterval: (value: number) => void;\n  showTopicToolbar?: boolean;\n  showKafkaToolbar?: boolean;\n  setSelectedTopic?: (value: string | boolean) => void;\n  selectedTopic?: string | boolean;\n  onRefreshKafkaToolbar?: () => void;\n  onRefreshTopicToolbar?: () => void;\n  topicList?: string[];\n  setIsFilterApplied?: (value: boolean) => void;\n};\nexport const ChartToolbar = ({\n  title,\n  showTopicFilter,\n  setTimeDuration,\n  setTimeInterval,\n  showKafkaToolbar = true,\n  showTopicToolbar = true,\n  setSelectedTopic,\n  selectedTopic,\n  onRefreshKafkaToolbar,\n  onRefreshTopicToolbar,\n  topicList,\n  setIsFilterApplied,\n}: ChartToolbarProps) => {\n  return (\n    <>\n      <Level>\n        <LevelItem>\n          <CardTitle component='h2'>{title}</CardTitle>\n        </LevelItem>\n        <LevelItem>\n          {showTopicFilter ? (\n            <Toolbar>\n              <ToolbarContent>\n                <FilterByTopic\n                  selectedTopic={selectedTopic}\n                  setSelectedTopic={setSelectedTopic}\n                  topicList={topicList}\n                  setIsFilterApplied={setIsFilterApplied}\n                  disableToolbar={!showTopicToolbar}\n                />\n                <FilterByTime\n                  setTimeDuration={setTimeDuration}\n                  setTimeInterval={setTimeInterval}\n                  disableToolbar={!showTopicToolbar}\n                  keyText={'topic-metrics-time-filter'}\n                />\n                <Button\n                  variant='plain'\n                  aria-label='sync'\n                  onClick={onRefreshTopicToolbar}\n                >\n                  <SyncIcon />\n                </Button>\n              </ToolbarContent>\n            </Toolbar>\n          ) : (\n            <Toolbar>\n              <ToolbarContent>\n                <FilterByTime\n                  setTimeDuration={setTimeDuration}\n                  setTimeInterval={setTimeInterval}\n                  keyText={'kafka-metrics-time-filter'}\n                  disableToolbar={!showKafkaToolbar}\n                />\n                <Button\n                  variant='plain'\n                  aria-label='sync'\n                  onClick={onRefreshKafkaToolbar}\n                >\n                  <SyncIcon />\n                </Button>\n              </ToolbarContent>\n            </Toolbar>\n          )}\n        </LevelItem>\n      </Level>\n      <Divider />\n    </>\n  );\n};\n"],"names":["ChartEmptyState","title","body","noData","noTopics","noFilter","onCreateTopic","EmptyState","variant","EmptyStateVariant","EmptyStateIcon","icon","Title","headingLevel","size","EmptyStateBody","Button","onClick","getLargestByteSize","data1","data2","currentByteSize","sortedData","data","map","datum","bytes","forEach","value","byteString","unit","convertToSpecifiedByte","largestByteSize","Math","round","formatTime","selection","timeDuration","timeInterval","ChartPopover","description","Popover","headerContent","bodyContent","UsedDiskSpaceChart","kafkaID","metricsDataUnavailable","setMetricsDataUnavailable","containerRef","useRef","t","useTranslation","auth","useAuth","basePath","useConfig","addAlert","useAlert","useState","width","setWidth","legend","setLegend","chartData","setChartData","chartDataLoading","setChartDataLoading","setLargestByteSize","setTimeDuration","setTimeInterval","handleResize","current","clientWidth","itemsPerRow","fetchUsedDiskSpaceMetrics","kas","getToken","undefined","accessToken","apisService","DefaultApi","Configuration","getMetricsByRangeQuery","name","items","item","index","labels","metric","Error","values","includes","indexJ","timestamp","newArray","usedSpaceAvg","concat","push","getChartData","reason","response","AlertVariant","useEffect","window","addEventListener","avgBroker","legendData","symbol","fill","chart_color_black_500","type","chart_color_blue_300","areaColor","softLimitColor","area","softLimit","getCurrentLengthOfData","length","lengthOfData","lengthOfDataPer5Mins","i","newTimestamp","date","Date","time","getHours","getMinutes","x","y","aggregateBytes","reduce","a","b","Card","ChartToolbar","showTopicFilter","showKafkaToolbar","onRefreshKafkaToolbar","CardTitle","component","CardBody","ref","Bullseye","Spinner","isSVG","Chart","ariaTitle","containerComponent","ChartVoronoiContainer","constrainToVisibleArea","legendPosition","legendComponent","ChartLegend","orientation","height","padding","bottom","left","right","top","themeColor","ChartThemeColor","minDomain","legendAllowWrap","ChartAxis","label","tickCount","dependentAxis","tickFormat","ChartGroup","ChartArea","key","interpolation","style","stroke","color","ChartThreshold","render","CursorVoronoiContainer","createContainer","this","props","topics","topic","messages","count","cursorDimension","labelComponent","ChartLegendTooltip","mouseFollowTooltips","voronoiDimension","voronoiPadding","maxDomain","showGrid","ChartLine","IncomingOutgoingBytesPerTopic","selectedTopic","setSelectedTopic","isFilterApplied","setIsFilterApplied","setNoTopics","topicList","setTopicList","fetchBytesData","rawData","Map","indexOf","has","get","set","sort","incomingTopicArray","outgoingTopicArray","line","chart_color_orange_300","showTopicToolbar","onRefreshTopicToolbar","Divider","LogSizePerPartitionChart","colors","chart_color_green_300","topicName","isTopicInArray","some","filteredTopics","filter","partitionArray","partition","newtimestamp","FilterByTopic","disableToolbar","isTopicSelectOpen","setIsTopicSelectOpen","topicListFinal","setTopicListFinal","topicOptions","SelectOption","SelectGroup","ToolbarItem","widths","default","sm","md","lg","xl","Select","SelectVariant","onToggle","onSelect","_","selections","isOpen","placeholderText","onFilter","textInput","isGrouped","hasInlineFilter","isDisabled","FilterByTime","keyText","selectedTime","setSelectedTime","isTimeSelectOpen","setIsTimeSelectOpen","timeOptions","Level","LevelItem","Toolbar","ToolbarContent"],"sourceRoot":""}