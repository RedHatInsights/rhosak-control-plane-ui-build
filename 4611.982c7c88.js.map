{"version":3,"file":"4611.982c7c88.js","mappings":"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","sources":["webpack://kas-ui/./src/app/hooks/usePageVisibility.ts","webpack://kas-ui/./src/app/modules/OpenshiftStreams/components/StreamsTableConnected/useKafkaStatusAlerts.tsx","webpack://kas-ui/./src/app/hooks/useInterval.ts","webpack://kas-ui/./src/app/modules/OpenshiftStreams/components/StreamsTableConnected/StreamsTableConnected.tsx","webpack://kas-ui/./src/app/modules/OpenshiftStreams/components/StreamsTableConnected/useCreateDialog.ts","webpack://kas-ui/./src/app/modules/OpenshiftStreams/components/StreamsTableConnected/useDeleteDialog.ts","webpack://kas-ui/./src/app/modules/OpenshiftStreams/components/StreamsTableConnected/useChangeOwnerDialog.ts","webpack://kas-ui/./src/app/modules/OpenshiftStreams/StreamsTableConnectedWithAuth.tsx","webpack://kas-ui/./src/app/modules/OpenshiftStreams/components/KafkaEmptyState/KafkaEmptyState.tsx","webpack://kas-ui/./src/app/modules/OpenshiftStreams/components/KasLayout/KasLayout.tsx"],"sourcesContent":["import { SetStateAction, Dispatch, useEffect, useState } from \"react\";\n\ntype XDocument = Document & {\n  msHidden: string;\n  webkitHidden: string;\n};\n\nexport function getBrowserVisibilityProp(): string {\n  const doc: XDocument = document as XDocument;\n  if (typeof doc.hidden !== \"undefined\") {\n    // Opera 12.10 and Firefox 18 and later support\n    return \"visibilitychange\";\n  } else if (typeof doc.msHidden !== \"undefined\") {\n    return \"msvisibilitychange\";\n  } else if (typeof doc.webkitHidden !== \"undefined\") {\n    return \"webkitvisibilitychange\";\n  }\n  return \"\";\n}\nexport function getBrowserDocumentHiddenProp(): keyof XDocument | undefined {\n  const doc: XDocument = document as XDocument;\n  if (typeof doc.hidden !== \"undefined\") {\n    return \"hidden\";\n  } else if (typeof doc.msHidden !== \"undefined\") {\n    return \"msHidden\";\n  } else if (typeof doc.webkitHidden !== \"undefined\") {\n    return \"webkitHidden\";\n  }\n  return undefined;\n}\nexport function getIsDocumentHidden(): boolean {\n  const hiddenKey = getBrowserDocumentHiddenProp();\n  return hiddenKey !== undefined && !(document as XDocument)[hiddenKey];\n}\n\nexport function usePageVisibility(): {\n  isVisible: boolean;\n  setIsVisible: Dispatch<SetStateAction<boolean>>;\n} {\n  const [isVisible, setIsVisible] = useState(getIsDocumentHidden());\n  const onVisibilityChange = () => setIsVisible(getIsDocumentHidden());\n  useEffect(() => {\n    const visibilityChange = getBrowserVisibilityProp();\n    document.addEventListener(visibilityChange, onVisibilityChange, false);\n    return () => {\n      document.removeEventListener(visibilityChange, onVisibilityChange);\n    };\n  }, []);\n  return { isVisible, setIsVisible };\n}\n","import { useCallback, useRef } from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { useAlert } from \"@rhoas/app-services-ui-shared\";\nimport { usePageVisibility } from \"@app/hooks/usePageVisibility\";\nimport { InstanceStatus } from \"@app/utils\";\nimport { AlertVariant } from \"@patternfly/react-core\";\nimport { useInterval } from \"@app/hooks/useInterval\";\nimport { KafkaInstanceEnhanced } from \"./useKafkaInstances\";\n\ntype AlertableInstance = { name: string; status: InstanceStatus };\n\nexport function useKafkaStatusAlerts(): (\n  instances: KafkaInstanceEnhanced[]\n) => void {\n  const { t } = useTranslation([\"kasTemporaryFixMe\"]);\n  const { addAlert } = useAlert() || {};\n  const { isVisible } = usePageVisibility();\n  const previousInstancesRef = useRef<KafkaInstanceEnhanced[]>();\n  const instancesBeingDeletedRef = useRef<KafkaInstanceEnhanced[]>([]);\n  const toNotifyRef = useRef<AlertableInstance[]>([]);\n\n  const notifyReady = useCallback(\n    (name: string) => {\n      addAlert({\n        title: t(\"kafka_successfully_created\"),\n        variant: AlertVariant.success,\n        description: (\n          <span\n            dangerouslySetInnerHTML={{\n              __html: t(\"kafka_success_message\", {\n                name,\n              }),\n            }}\n          />\n        ),\n        dataTestId: \"toastCreateKafka-success\",\n      });\n    },\n    [addAlert, t]\n  );\n\n  const notifyDelete = useCallback(\n    (name: string) => {\n      addAlert({\n        title: t(\"kafka_successfully_deleted\", {\n          name,\n        }),\n        variant: AlertVariant.success,\n      });\n    },\n    [addAlert, t]\n  );\n\n  const notifyFailure = useCallback(\n    (name: string) => {\n      addAlert({\n        title: t(\"kafka_not_created\"),\n        variant: AlertVariant.danger,\n        description: (\n          <span\n            dangerouslySetInnerHTML={{\n              __html: t(\"kafka_failed_message\", {\n                name,\n              }),\n            }}\n          />\n        ),\n        dataTestId: \"toastCreateKafka-failed\",\n      });\n    },\n    [addAlert, t]\n  );\n\n  // check every second if the browser is visible, and if so send the queued\n  // notifications\n  useInterval(\n    useCallback(\n      function sendNotificationCb() {\n        if (isVisible) {\n          while (toNotifyRef.current.length > 0) {\n            const instance = toNotifyRef.current.shift()!;\n            switch (instance.status) {\n              case InstanceStatus.READY:\n                notifyReady(instance.name);\n                break;\n              case InstanceStatus.FAILED:\n                notifyFailure(instance.name);\n                break;\n              case InstanceStatus.DEPROVISION:\n              case InstanceStatus.DELETED:\n                notifyDelete(instance.name);\n                break;\n            }\n          }\n        }\n      },\n      [isVisible, notifyDelete, notifyFailure, notifyReady]\n    ),\n    1000\n  );\n\n  function checkForInstanceStatusChange(instances: KafkaInstanceEnhanced[]) {\n    if (instances) {\n      const firstData = previousInstancesRef.current === undefined;\n      const previousInstances = previousInstancesRef.current || [];\n\n      const previousIdsAndStates = previousInstances.map(\n        (i) => `${i.id}:${i.status}`\n      );\n      const currentIdsAndStates = instances.map((i) => `${i.id}:${i.status}`);\n\n      // Check for changes between polled data in an unefficent but effective way.\n      // We don't stringify the whole KafkaInstanceEnhanced object since it's massive and\n      // we care only about an instance id and its status.\n      if (\n        JSON.stringify(previousIdsAndStates) !==\n        JSON.stringify(currentIdsAndStates)\n      ) {\n        // an helper function to get the instances that changed state, but only\n        // if we got at least one snapshot of the data. We don't want to notify\n        // again for instances already created.\n        const filterInstances = (\n          instances: KafkaInstanceEnhanced[],\n          desiredStatus: InstanceStatus\n        ) => {\n          return firstData\n            ? []\n            : instances.filter((i) => {\n                const previousState = previousInstances.find(\n                  (pi) => pi.id === i.id\n                );\n                if (!previousState) {\n                  // first time we see this instance, we'll ignore it\n                  return false;\n                } else {\n                  return (\n                    i.status === desiredStatus &&\n                    previousState.status !== desiredStatus\n                  );\n                }\n              });\n        };\n\n        // get newly created and failed instances\n        const ready = filterInstances(instances, InstanceStatus.READY);\n        const failed = filterInstances(instances, InstanceStatus.FAILED);\n        // since it's possible that an instance that is being deleted will\n        // simply not be returned the next time we poll for data, we keep track\n        // of instances that are deprovisoning in a ref. We check if these\n        // instances are still in the current list of instances. If not, they\n        // have been deleted and we should notify the user. The others, we keep\n        // them in the ref\n        const [deleted, stillBeingDeleted] =\n          instancesBeingDeletedRef.current.reduce<\n            [KafkaInstanceEnhanced[], KafkaInstanceEnhanced[]]\n          >(\n            ([deleted, beingDeleted], instanceBeingDeleted) => {\n              if (\n                instances.find((i) => i.id === instanceBeingDeleted.id) ===\n                undefined\n              ) {\n                // this instance has been deleted\n                return [[...deleted, instanceBeingDeleted], beingDeleted];\n              } else {\n                return [deleted, [...beingDeleted, instanceBeingDeleted]];\n              }\n            },\n            [[], []]\n          );\n\n        // check also for new instances being deleted\n        const newBeingDeleted = instances.filter(\n          (i) =>\n            [InstanceStatus.DELETED, InstanceStatus.DEPROVISION].includes(\n              i.status as InstanceStatus\n            ) && stillBeingDeleted.find((s) => s.id === i.id) === undefined\n        );\n\n        // recreate the deleted instances ref with the data derived before\n        instancesBeingDeletedRef.current = [\n          ...stillBeingDeleted,\n          ...newBeingDeleted,\n        ];\n\n        // update the ref of instances for which we need to notify the user\n        toNotifyRef.current = [\n          ...toNotifyRef.current,\n          ...ready.map(instanceToAlertable),\n          ...failed.map(instanceToAlertable),\n          ...deleted.map(instanceToAlertable),\n        ];\n\n        // snapshot the instances used in this run\n        previousInstancesRef.current = instances;\n      }\n    }\n  }\n\n  return checkForInstanceStatusChange;\n}\n\nfunction instanceToAlertable(\n  instance: KafkaInstanceEnhanced\n): AlertableInstance {\n  return { name: instance.name!, status: instance.status as InstanceStatus };\n}\n","import { useEffect, useRef } from \"react\";\n\nexport function useInterval(callback: () => void, delay: number): void {\n  const savedCallback = useRef<() => void>();\n\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    function tick() {\n      savedCallback.current && savedCallback.current();\n    }\n    if (delay !== null) {\n      const id = setInterval(tick, delay);\n      return () => {\n        clearInterval(id);\n      };\n    }\n    return;\n  }, [delay]);\n}\n","// eslint-disable @typescript-eslint/no-unused-vars\nimport { FederatedProps } from \"@app/contexts\";\nimport \"@app/modules/styles.css\";\nimport {\n  KafkaInstances,\n  KafkaInstancesProps,\n} from \"@rhoas/app-services-ui-components\";\nimport { useCallback, useContext, VoidFunctionComponent } from \"react\";\nimport { KafkaInstanceEnhanced, useKafkaInstances } from \"./useKafkaInstances\";\nimport { useInstanceDrawer } from \"@app/modules/InstanceDrawer/contexts/InstanceDrawerContext\";\nimport { InstanceDrawerTab } from \"@app/modules/InstanceDrawer/tabs\";\nimport { useCreateDialog } from \"./useCreateDialog\";\nimport { useDeleteDialog } from \"./useDeleteDialog\";\nimport { useChangeOwnerDialog } from \"./useChangeOwnerDialog\";\nimport { useKafkaStatusAlerts } from \"./useKafkaStatusAlerts\";\nimport { QuickStartContext } from \"@patternfly/quickstarts\";\nimport { InstanceStatus } from \"@app/utils\";\n\nexport type StreamsTableProps = Pick<FederatedProps, \"preCreateInstance\"> & {\n  currentUser: string | undefined;\n  isCurrentUserOrgAdmin: boolean;\n};\n\nexport const StreamsTableConnected: VoidFunctionComponent<\n  StreamsTableProps\n> = ({\n  preCreateInstance,\n  currentUser,\n  isCurrentUserOrgAdmin,\n}: StreamsTableProps) => {\n  const fetchInstances = useKafkaInstances();\n  const { openCreateModal } = useCreateDialog(preCreateInstance);\n  const { openDeleteDialog } = useDeleteDialog();\n  const { openChangeOwnerDialog } = useChangeOwnerDialog();\n  const notifyForInstanceChange = useKafkaStatusAlerts();\n  const { setActiveQuickStart } = useContext(QuickStartContext);\n\n  const {\n    isDrawerOpen,\n    drawerInstance,\n    closeDrawer,\n    openDrawer,\n    setDrawerActiveTab,\n    setDrawerInstance,\n  } = useInstanceDrawer();\n\n  /*\n              Fetch the latest instances for the user specified query, and checks the\n              returned instances.\n          \n              If we have the drawer open but the data doesn't\n              contain the instance anymore (eg. the instance got removed by someone else)\n              we close the drawer. If we have the drawer open and we found the relative\n              instance, we update the object the drawer uses to render the drawer to be\n              sure it's referring to the latest data (needed for the connection info).\n          \n              This triggers also the notifications for ready/deleted instances.\n             */\n  const getInstances: KafkaInstancesProps<KafkaInstanceEnhanced>[\"getInstances\"] =\n    useCallback(\n      async (...args) => {\n        const res = await fetchInstances(...args);\n        if (drawerInstance) {\n          const latestDrawerInstanceData = res.instances.find(\n            (i) => i.id === drawerInstance.id\n          );\n          if (!latestDrawerInstanceData) {\n            closeDrawer();\n          } else {\n            /* we have to check if there is actually some difference between\n                      the previous data and the current one to avoid render loops */\n            if (\n              JSON.stringify(latestDrawerInstanceData) !==\n              JSON.stringify(drawerInstance)\n            ) {\n              setDrawerInstance(latestDrawerInstanceData);\n            }\n          }\n        }\n        notifyForInstanceChange(\n          res.instances.filter((i) => i.owner == currentUser)\n        );\n        return res;\n      },\n      [\n        closeDrawer,\n        currentUser,\n        drawerInstance,\n        fetchInstances,\n        notifyForInstanceChange,\n        setDrawerInstance,\n      ]\n    );\n\n  const onViewInstance = (instance: KafkaInstanceEnhanced) => {\n    setDrawerInstance(instance);\n    setDrawerActiveTab(InstanceDrawerTab.DETAILS);\n    openDrawer();\n  };\n\n  const onViewConnection = (instance: KafkaInstanceEnhanced) => {\n    setDrawerInstance(instance);\n    setDrawerActiveTab(InstanceDrawerTab.CONNECTION);\n    openDrawer();\n  };\n\n  const isUserOwnerOrAdmin = useCallback(\n    ({ owner }: KafkaInstanceEnhanced) =>\n      owner === currentUser || isCurrentUserOrgAdmin,\n    [currentUser, isCurrentUserOrgAdmin]\n  );\n\n  const canChangeOwner = useCallback(\n    ({ owner, status }: KafkaInstanceEnhanced) =>\n      owner === currentUser ||\n      (isCurrentUserOrgAdmin && status !== InstanceStatus.SUSPENDED),\n    [currentUser, isCurrentUserOrgAdmin]\n  );\n\n  const onQuickstartGuide = useCallback(\n    () => setActiveQuickStart && setActiveQuickStart(\"getting-started\"),\n    [setActiveQuickStart]\n  );\n\n  const onClickSupportLink = () => {\n    // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n    (window as unknown as any).insights.chrome.createCase();\n  };\n\n  const canHaveInstanceLink = (KafkaInstance: KafkaInstanceEnhanced) => {\n    return KafkaInstance.status === InstanceStatus.READY;\n  };\n\n  const canOpenConnection = (KafkaInstance: KafkaInstanceEnhanced) => {\n    return KafkaInstance.status !== InstanceStatus.SUSPENDED;\n  };\n\n  return (\n    <KafkaInstances\n      isRowSelected={({ row }) => isDrawerOpen && row.id === drawerInstance?.id}\n      getInstances={getInstances}\n      getUrlForInstance={({ id }) => `./kafkas/${id}/dashboard`}\n      onCreate={openCreateModal}\n      onDetails={onViewInstance}\n      onConnection={onViewConnection}\n      onChangeOwner={openChangeOwnerDialog}\n      onDelete={openDeleteDialog}\n      onClickConnectionTabLink={onViewConnection}\n      onClickSupportLink={onClickSupportLink}\n      onInstanceLinkClick={closeDrawer}\n      onQuickstartGuide={onQuickstartGuide}\n      canChangeOwner={canChangeOwner}\n      canDelete={isUserOwnerOrAdmin}\n      canHaveInstanceLink={canHaveInstanceLink}\n      canOpenConnection={canOpenConnection}\n    />\n  );\n};\n","import {\n  KafkaInstancesProps,\n  useURLSearchParams,\n} from \"@rhoas/app-services-ui-components\";\nimport { useCallback, useEffect } from \"react\";\nimport { FederatedProps, useFederated } from \"@app/contexts\";\nimport { ModalType, useModal } from \"@rhoas/app-services-ui-shared\";\nimport { KafkaInstanceEnhanced } from \"./useKafkaInstances\";\nimport useChrome from \"@redhat-cloud-services/frontend-components/useChrome\";\n\nexport function useCreateDialog(\n  preCreateInstance: FederatedProps[\"preCreateInstance\"] = () =>\n    Promise.resolve(true)\n) {\n  const { analytics } = useChrome();\n  const { shouldOpenCreateModal } = useFederated();\n  const { showModal: showCreateModal } =\n    useModal<ModalType.KasCreateInstance>();\n  const { update, query } = useURLSearchParams();\n\n  const openCreateModal: KafkaInstancesProps<KafkaInstanceEnhanced>[\"onCreate\"] =\n    useCallback(\n      async (onDone) => {\n        analytics.track(\"RHOSAK Create Instance\", { status: \"prompt\" });\n        // Callback before opening create dialog\n        // The callback can override the new state of opening\n        if (await preCreateInstance(true)) {\n          showCreateModal(ModalType.KasCreateInstance, {\n            onCreate: () => {\n              analytics.track(\"RHOSAK Create Instance\", {\n                status: \"success\",\n              });\n              onDone();\n            },\n          });\n        } else {\n          analytics.track(\"RHOSAK Create Instance\", {\n            status: \"failure-tos-refused\",\n          });\n        }\n      },\n      [analytics, preCreateInstance, showCreateModal]\n    );\n\n  /*\n    Checks for the ?create=true parameter in the url\n\n    If found, it does the pre create instance checks (the Terms & Conditions\n    check) then opens the modal. The parameter gets removed from the url to\n    avoid loops and to make refreshing the page a safe action (the modal will\n    not be opened again)\n   */\n  useEffect(() => {\n    async function checkForCreateModal() {\n      if (await shouldOpenCreateModal()) {\n        query.delete(\"create\");\n        update(query);\n        if (await preCreateInstance(true)) {\n          showCreateModal(ModalType.KasCreateInstance, {\n            onCreate: () => {\n              /* do nothing */\n            },\n          });\n        }\n      }\n    }\n    void checkForCreateModal();\n  }, [\n    openCreateModal,\n    preCreateInstance,\n    query,\n    shouldOpenCreateModal,\n    showCreateModal,\n    update,\n  ]);\n\n  return {\n    openCreateModal,\n  };\n}\n","import { KafkaInstancesProps } from \"@rhoas/app-services-ui-components\";\nimport { KafkaInstanceEnhanced } from \"./useKafkaInstances\";\nimport { useCallback } from \"react\";\nimport { ModalType, useModal } from \"@rhoas/app-services-ui-shared\";\nimport useChrome from \"@redhat-cloud-services/frontend-components/useChrome\";\n\nexport function useDeleteDialog() {\n  const { analytics } = useChrome();\n  const { showModal: showDeleteModal } =\n    useModal<ModalType.KasDeleteInstance>();\n  const openDeleteDialog: KafkaInstancesProps<KafkaInstanceEnhanced>[\"onDelete\"] =\n    useCallback(\n      (instance, onDone) => {\n        analytics.track(\"RHOSAK Delete Instance\", {\n          status: \"prompt\",\n          entityId: instance.id,\n        });\n        showDeleteModal(ModalType.KasDeleteInstance, {\n          onDelete: () => {\n            analytics.track(\"RHOSAK Delete Instance\", {\n              status: \"success\",\n              entityId: instance.id,\n            });\n            onDone();\n          },\n          kafka: instance.request,\n        });\n      },\n      [analytics, showDeleteModal]\n    );\n  return {\n    openDeleteDialog,\n  };\n}\n","import { KafkaInstancesProps } from \"@rhoas/app-services-ui-components\";\nimport { KafkaInstanceEnhanced } from \".//useKafkaInstances\";\nimport { useCallback } from \"react\";\nimport { ModalType, useModal } from \"@rhoas/app-services-ui-shared\";\n\nexport function useChangeOwnerDialog() {\n  const { showModal: showTransferOwnershipModal } =\n    useModal<ModalType.KasTransferOwnership>();\n\n  const openChangeOwnerDialog: KafkaInstancesProps<KafkaInstanceEnhanced>[\"onChangeOwner\"] =\n    useCallback(\n      (instance, onDone) => {\n        showTransferOwnershipModal(ModalType.KasTransferOwnership, {\n          kafka: instance.request,\n          refreshKafkas: onDone,\n        });\n      },\n      [showTransferOwnershipModal]\n    );\n\n  return { openChangeOwnerDialog };\n}\n","import { useEffect, useState, VoidFunctionComponent } from \"react\";\nimport {\n  StreamsTableConnected,\n  StreamsTableProps,\n} from \"@app/modules/OpenshiftStreams/components/StreamsTableConnected\";\nimport { useAuth } from \"@rhoas/app-services-ui-shared\";\n\nexport const StreamsTableConnectedWithAuth: VoidFunctionComponent<\n  Pick<StreamsTableProps, \"preCreateInstance\">\n> = ({ preCreateInstance }) => {\n  const { getUsername, isOrgAdmin } = useAuth();\n  const [user, setUser] = useState<\n    Pick<StreamsTableProps, \"currentUser\" | \"isCurrentUserOrgAdmin\"> | undefined\n  >(undefined);\n\n  useEffect(() => {\n    async function getUser() {\n      const username = await getUsername();\n      const orgAdmin = await isOrgAdmin();\n\n      if (username !== undefined && orgAdmin !== undefined) {\n        setUser({\n          currentUser: username,\n          isCurrentUserOrgAdmin: orgAdmin,\n        });\n      }\n    }\n\n    void getUser();\n  }, [getUsername, isOrgAdmin]);\n\n  return (\n    <StreamsTableConnected\n      preCreateInstance={preCreateInstance}\n      currentUser={user?.currentUser}\n      isCurrentUserOrgAdmin={user?.isCurrentUserOrgAdmin || false}\n    />\n  );\n};\n","import { FunctionComponent, useContext } from \"react\";\nimport { Trans, useTranslation } from \"react-i18next\";\nimport {\n  QuickStartContext,\n  QuickStartContextValues,\n} from \"@patternfly/quickstarts\";\nimport { Button, ButtonVariant, PageSection } from \"@patternfly/react-core\";\nimport { MASEmptyState, MASEmptyStateVariant } from \"@app/common\";\n\nexport type KafkaEmptyStateProps = {\n  handleCreateInstanceModal: () => void;\n};\nexport const KafkaEmptyState: FunctionComponent<KafkaEmptyStateProps> = ({\n  handleCreateInstanceModal,\n}) => {\n  const { t } = useTranslation([\"kasTemporaryFixMe\"]);\n  const qsContext: QuickStartContextValues = useContext(QuickStartContext);\n  return (\n    <PageSection padding={{ default: \"noPadding\" }} isFilled>\n      <MASEmptyState\n        emptyStateProps={{\n          variant: MASEmptyStateVariant.NoItems,\n        }}\n        emptyStateBodyProps={{\n          body: (\n            <>\n              <Trans\n                i18nKey=\"create_a_kafka_instance_to_get_started\"\n                ns={[\"kasTemporaryFixMe\"]}\n                components={[\n                  <Button\n                    variant={ButtonVariant.link}\n                    isSmall\n                    isInline\n                    key=\"btn-quick-start\"\n                    onClick={() =>\n                      qsContext.setActiveQuickStart &&\n                      qsContext.setActiveQuickStart(\"getting-started\")\n                    }\n                  />,\n                ]}\n              />\n            </>\n          ),\n        }}\n        titleProps={{ title: t(\"no_kafka_instances_yet\") }}\n      >\n        <Button\n          data-testid=\"emptyStateStreams-buttonCreateKafka\"\n          variant={ButtonVariant.primary}\n          onClick={() =>\n            handleCreateInstanceModal && handleCreateInstanceModal()\n          }\n          ouiaId=\"button-create\"\n        >\n          {t(\"create_kafka_instance\")}\n        </Button>\n      </MASEmptyState>\n    </PageSection>\n  );\n};\n","import { FunctionComponent, useEffect, useState } from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { isMobileTablet } from \"@app/utils\";\nimport {\n  Button,\n  Level,\n  LevelItem,\n  Modal,\n  ModalVariant,\n  PageSection,\n  PageSectionVariants,\n  Text,\n  TextContent,\n} from \"@patternfly/react-core\";\n\nexport const KasLayout: FunctionComponent = ({ children }) => {\n  const { t } = useTranslation([\"kasTemporaryFixMe\"]);\n  const [isMobileModalOpen, setIsMobileModalOpen] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (isMobileTablet()) {\n      const localStorage = window.localStorage;\n      if (localStorage) {\n        const count = parseInt(localStorage.getItem(\"openSessions\") || \"0\");\n        const newCount = count + 1;\n        if (count < 1) {\n          localStorage.setItem(\"openSessions\", `${newCount}`);\n          setIsMobileModalOpen(true);\n        }\n      }\n    }\n  }, []);\n\n  const handleMobileModal = () => {\n    setIsMobileModalOpen(!isMobileModalOpen);\n  };\n\n  return (\n    <>\n      <main className=\"pf-c-page__main\">\n        <PageSection variant={PageSectionVariants.light}>\n          <Level>\n            <LevelItem>\n              <TextContent>\n                <Text component=\"h1\">{t(\"kafka_instances\")}</Text>\n              </TextContent>\n            </LevelItem>\n          </Level>\n        </PageSection>\n        {children}\n      </main>\n      <Modal\n        variant={ModalVariant.small}\n        title=\"Mobile experience\"\n        isOpen={isMobileModalOpen}\n        onClose={() => handleMobileModal()}\n        actions={[\n          <Button\n            key=\"confirm\"\n            variant=\"primary\"\n            onClick={() => handleMobileModal()}\n          >\n            Ok\n          </Button>,\n        ]}\n      >\n        The mobile experience isn&apos;t fully optimized yet, so some items\n        might not appear correctly.\n      </Modal>\n    </>\n  );\n};\n"],"names":["getIsDocumentHidden","hiddenKey","doc","document","hidden","msHidden","webkitHidden","getBrowserDocumentHiddenProp","undefined","usePageVisibility","isVisible","setIsVisible","useState","onVisibilityChange","useEffect","visibilityChange","getBrowserVisibilityProp","addEventListener","removeEventListener","useKafkaStatusAlerts","t","useTranslation","addAlert","useAlert","previousInstancesRef","useRef","instancesBeingDeletedRef","toNotifyRef","notifyReady","useCallback","name","title","variant","AlertVariant","description","dangerouslySetInnerHTML","__html","dataTestId","notifyDelete","notifyFailure","callback","delay","savedCallback","current","id","setInterval","clearInterval","useInterval","length","instance","shift","status","instances","firstData","previousInstances","previousIdsAndStates","map","i","currentIdsAndStates","JSON","stringify","filterInstances","desiredStatus","filter","previousState","find","pi","ready","failed","deleted","stillBeingDeleted","reduce","beingDeleted","instanceBeingDeleted","newBeingDeleted","includes","s","instanceToAlertable","StreamsTableConnected","preCreateInstance","currentUser","isCurrentUserOrgAdmin","fetchInstances","useKafkaInstances","openCreateModal","Promise","resolve","analytics","useChrome","shouldOpenCreateModal","showModal","showCreateModal","useModal","update","query","useURLSearchParams","onDone","track","ModalType","onCreate","delete","checkForCreateModal","useCreateDialog","openDeleteDialog","showDeleteModal","entityId","onDelete","kafka","request","useDeleteDialog","openChangeOwnerDialog","showTransferOwnershipModal","refreshKafkas","useChangeOwnerDialog","notifyForInstanceChange","setActiveQuickStart","useContext","QuickStartContext","isDrawerOpen","drawerInstance","closeDrawer","openDrawer","setDrawerActiveTab","setDrawerInstance","getInstances","args","res","latestDrawerInstanceData","owner","onViewConnection","isUserOwnerOrAdmin","canChangeOwner","onQuickstartGuide","KafkaInstances","isRowSelected","row","getUrlForInstance","onDetails","onConnection","onChangeOwner","onClickConnectionTabLink","onClickSupportLink","window","insights","chrome","createCase","onInstanceLinkClick","canDelete","canHaveInstanceLink","KafkaInstance","canOpenConnection","StreamsTableConnectedWithAuth","getUsername","isOrgAdmin","useAuth","user","setUser","username","orgAdmin","getUser","KasLayout","children","isMobileModalOpen","setIsMobileModalOpen","localStorage","count","parseInt","getItem","newCount","setItem","handleMobileModal","className","PageSection","PageSectionVariants","Level","LevelItem","TextContent","Text","component","Modal","ModalVariant","isOpen","onClose","actions","Button","onClick"],"sourceRoot":""}