{"version":3,"file":"3876.082e1022.js","mappings":"oLAsBaA,EAAkB,SAAC,G,IAC9BC,EAAK,QACLC,EAAI,OACJC,EAAM,SACNC,EAAQ,WACRC,EAAQ,WACRC,EAAa,gBAab,OACE,kBAAC,EAAAC,WAAU,CAACC,QAAS,EAAAC,kBAAA,IACnB,kBAAC,EAAAC,eAAc,CAACC,KAZdR,EACK,KACEC,EACF,KACEC,EACF,UADF,IASL,kBAAC,EAAAO,MAAK,CAACC,aAAa,KAAKC,KAAK,MAC3Bb,GAEH,kBAAC,EAAAc,eAAc,KACZb,EACD,6BACA,6BACCE,GACC,kBAAC,EAAAY,OAAM,CAACR,QAAQ,UAAUS,QAASX,GAAa,oB,0OClD7CY,EAAqB,SAACC,EAAOC,GACxC,IAAIC,EAAkB,IAyDtB,OAvDAF,EAAQA,IAAUA,EAAMG,WAAaH,EAAMG,WAAaH,EAAMI,MAC9DH,EAAQA,IAAUA,EAAME,WAAaF,EAAME,WAAaF,EAAMG,MAE9DJ,GACEA,EAAMK,KAAI,SAACC,GACTA,EAAMC,MAAMC,SAAQ,SAACC,GACnB,IAAMC,EAAa,IAASD,GAAOE,KAChB,QAAfD,GACsB,MAApBR,IACFA,EAAkB,OAGH,QAAfQ,IACsB,MAApBR,GAA+C,QAApBA,IAC7BA,EAAkB,QAGH,QAAfQ,IAEoB,MAApBR,GACoB,QAApBA,GACoB,QAApBA,IAEAA,EAAkB,cAM5BD,GACEA,EAAMI,KAAI,SAACC,GACTA,EAAMC,MAAMC,SAAQ,SAACC,GACnB,IAAMC,EAAa,IAASD,GAAOE,KAChB,QAAfD,GACsB,MAApBR,IACFA,EAAkB,OAGH,QAAfQ,IACsB,MAApBR,GAA+C,QAApBA,IAC7BA,EAAkB,QAGH,QAAfQ,IAEoB,MAApBR,GACoB,QAApBA,GACoB,QAApBA,IAEAA,EAAkB,cAMrBA,GAGIU,EAAyB,SACpCL,EACAM,GAEA,MAAwB,MAApBA,EACKC,KAAKC,MAAc,GAARR,GAAc,GAEV,QAApBM,EACKC,KAAKC,MAAOR,EAAQ,KAAQ,IAAM,GAEnB,QAApBM,EACKC,KAAKC,MAAOR,EAAQ,KAAO,KAAQ,IAAM,GAE1B,QAApBM,EACKC,KAAKC,MAAOR,EAAQ,KAAO,KAAO,KAAQ,IAAM,GAElDA,GAGIS,EAAiB,SAACC,GAC7B,OAAOA,GAAgB,IAGZC,EAAmB,SAACC,EAAM,G,IAAEC,EAAQ,WACzC,EAAyBD,EAAKE,cAAcC,MAAM,KAAjDC,EAAS,KAAEC,EAAS,KAC3B,OAAOJ,EACHI,EAAUC,MAAM,EAAG,GAAK,KAAOF,EAC/BC,EAAUC,MAAM,EAAG,IAUZC,EAAa,SAACC,GACzB,IAAIV,EAAe,EACfW,EAAe,GACnB,OAAQD,GACN,IAAK,iBACHV,EAAe,EAAI,GACnBW,EAAe,EACf,MACF,IAAK,kBACHX,EAAe,IACfW,EAAe,EACf,MACF,IAAK,kBACHX,EAAe,GACfW,EAAe,EACf,MACF,IAAK,cACHX,EAAe,EACfW,EAAe,GACf,MACF,IAAK,eACHX,EAAe,EACfW,EAAe,GACf,MACF,IAAK,eACHX,EAAe,EACfW,EAAe,GACf,MACF,IAAK,gBACHX,EAAe,GACfW,EAAe,IACf,MACF,IAAK,gBACHX,EAAe,GACfW,EAAe,IACf,MACF,IAAK,cACHX,EAAe,GACfW,EAAe,IACf,MACF,IAAK,cACHX,EAAe,IACfW,EAAe,KAGnB,MAAO,CAAEX,aAAY,EAAEW,aAAY,I,WCxIxBC,EAAe,SAAC,G,IAAE/C,EAAK,QAAEgD,EAAW,cAC/C,OACE,kBAAC,EAAAC,QAAO,cACK,gBACXC,cAAe,6BAAMlD,GACrBmD,YAAa,6BAAMH,IAEnB,kBAAC,KAA0B,QCiDpBI,EAAmD,SAAC,G,IAC/DC,EAAO,UACPC,EAAsB,yBACtBC,EAAyB,4BAEnBC,GAAe,IAAAC,QAAuB,MACpCC,GAAM,IAAAC,kBAAgB,EACxBC,GAAO,IAAAC,WAEQC,KADL,IAAAC,cAAe,IAAE,KACQ,IAAE,YACnCC,IAAa,IAAAC,aAAc,IAAE,SAC/B,GAAoB,IAAAC,YAAnBC,EAAK,KAAEC,EAAQ,KAChB,GAAsB,IAAAF,YAArBG,EAAM,KAAEC,EAAS,KAClB,GAA4B,IAAAJ,YAA3BK,EAAS,KAAEC,EAAY,KACxB,GAA0C,IAAAN,WAAS,GAAlDO,EAAgB,KAAEC,EAAmB,KACtC,GAAwC,IAAAR,YAAvCnC,EAAe,KAAE4C,EAAkB,KACpC,GAAkC,IAAAT,UAAS,GAA1C/B,EAAY,KAAEyC,EAAe,KAC9B,GAAkC,IAAAV,UAAS,IAA1CpB,EAAY,KAAE+B,EAAe,KAG9BC,EAAe,WACnB,OAAAtB,EAAauB,SAAWX,EAASZ,EAAauB,QAAQC,cAClDC,EAAcd,GAASA,EAAQ,IAAM,EAAI,EAEzCe,EAA4B,kE,qFACZ,SAAMtB,MAAAA,OAAI,EAAJA,EAAMuB,IAAIC,Y,eAChBC,KADdC,EAAc,WAC6B,KAAhBA,EAA7B,Y,iBAQA,O,sBANMC,EAAc,IAAI,EAAAC,WACtB,IAAI,EAAAC,cAAc,CAChBH,YAAW,EACXxB,SAAQ,KAGPT,EAIQ,GAAMkC,EAAYG,uBAC7BrC,EACe,GAAflB,EACe,GAAfW,EACA,CAAC,qCAPD,I,cAGIxB,EAAO,SAOP,EAAY,CAChBqE,KAAM,kBACNrE,KAAM,IAGJA,EAAKA,KAAKsE,OACZrC,GAA0B,GACX,QAAf,EAAAjC,EAAKA,KAAKsE,aAAK,SAAElE,SAAQ,SAACmE,EAAMC,G,MACxBC,EAASF,EAAKG,OAEpB,QAAeX,IAAXU,EACF,MAAM,IAAIE,MAAM,mCAElB,QAAoBZ,IAAhBQ,EAAKK,OACP,MAAM,IAAID,MAAM,mCAES,oCAAvBF,EAAiB,WACHA,EAA8B,sBAEjCI,SAAS,cACT,QAAX,EAAAN,EAAKK,cAAM,SAAExE,SAAQ,SAACC,EAAOyE,GAC3B,GAAuBf,MAAnB1D,EAAM0E,UACR,MAAM,IAAIJ,MAAM,iCAGlB,GAAIH,EAAQ,EAAG,CACb,IAAMQ,EAAW,EAAUhF,KAAK8E,GAAQG,aAAaC,OACnD7E,EAAMA,OAER,EAAUL,KAAK8E,GAAQG,aAAeD,OAEtC,EAAUhF,KAAKmF,KAAK,CAClBJ,UAAW1E,EAAM0E,UACjBE,aAAc,CAAC5E,EAAMA,aAO/B+E,EAAa,QAGfnD,GAA0B,GAC1BmB,GAAoB,I,+BAGlBiC,OAAM,GACN,QAAkB,KACpBA,EAAuB,QAAd,IAAMC,gBAAQ,eAAEtF,KAAKqF,QAEhC3C,GACEA,EAAS,CACPzD,QAAS,EAAAsG,aAAA,OACT7G,MAAO0D,EAAE,+BACTV,YAAa2D,I,gCAMvB,IAAAG,YAAU,WACR5B,IACAJ,MACC,CAAC3C,EAAcW,KAIlB,IAAAgE,YAAU,WACRhC,IACAiC,OAAOC,iBAAiB,SAAUlC,KACjC,CAACX,IAEJ,IAAMuC,EAAe,SAACO,GACpB,IAAMC,EAAgC,CACpC,CACEvB,KAAM,QACNwB,OAAQ,CAAEC,KAAMC,EAAA,SAA6BC,KAAM,cAErD,CAAE3B,KAAMsB,EAAUtB,KAAMwB,OAAQ,CAAEC,KAAMG,EAAA,YAGpCC,EAAYD,EAAA,SACZE,EAAiBJ,EAAA,SACjB9C,EAA8B,GAC9BmD,EAA+B,GAC/BC,EAAoC,GAGpCC,EAAyB,WAK7B,OAHEX,EAAU3F,KAAK2F,EAAU3F,KAAKuG,OAAS,GAAGxB,UAC1CY,EAAU3F,KAAK,GAAG+E,WACY,IAAO,IAInCyB,EAAe,IAASF,IACxBG,GAAwB,IAASH,KAA4B,EAEnE,GAAIE,GAAgB,KAAO3F,GAAgB,EACzC,IAAK,IAAI6F,EAAI,EAAGA,EAAID,EAAsBC,GAAQ,EAAG,CACnD,IAAMC,EACJhB,EAAU3F,KAAK,GAAG+E,UACW,KAA5B0B,EAAuBC,GACpB3F,EAAO,IAAI6F,KAAKD,GAChBE,EAAO/F,EAAiBC,EAAM,CAClCC,SAAUJ,EAAeC,KAE3BuF,EAAKjB,KAAK,CAAEd,KAAMsB,EAAUtB,KAAMyC,EAAGD,EAAME,EAAG,IAC9CV,EAAUlB,KAAK,CAAEd,KAAM,QAASyC,EAAGD,EAAME,EAzI5B,KA6IjBpB,EAAU3F,KAAKC,KAAI,SAACI,GAClB,IAAMU,EAAO,IAAI6F,KAAKvG,EAAM0E,WACtB8B,EAAO/F,EAAiBC,EAAM,CAClCC,SAAUJ,EAAeC,KAErBmG,EAAiB3G,EAAM4E,aAAagC,QAAO,SAAUC,EAAGC,GAC5D,OAAOD,EAAIC,IACV,GAEGhH,EAAQK,EAAuBwG,EApCf,OAqCtBZ,EAAKjB,KAAK,CAAEd,KAAMsB,EAAUtB,KAAMyC,EAAGD,EAAME,EAAG5G,IAC9CkG,EAAUlB,KAAK,CAAEd,KAAM,QAASyC,EAAGD,EAAME,EAxJ1B,QA0JjB9D,EAAUkC,KAAK,CAAEe,UAAS,EAAEC,eAAc,EAAEC,KAAI,EAAEC,UAAS,IAE3DrD,EAAU4C,GACV1C,EAAaD,GACbI,EA5CwB,OA6CxBD,GAAoB,IAOtB,OACE,kBAAC,EAAAgE,KAAI,KACH,kBAACC,EAAY,CACXC,iBAAiB,EACjB5I,MAAO0D,EAAE,kCACTkB,gBAAiBA,EACjBC,gBAAiBA,EACjBgE,kBAAmBvF,EACnBwF,sBAZwB,WAC5B5D,OAaE,kBAAC,EAAA6D,UAAS,CAACC,UAAU,MAClBtF,EAAE,2BAA4B,IAC/B,kBAACX,EAAY,CACX/C,MAAO0D,EAAE,2BACTV,YAAaU,EAAE,wCAGnB,kBAAC,EAAAuF,SAAQ,KACP,yBAAKC,IAAK1F,GACNiB,EAyEA,kBAAC,EAAA0E,SAAQ,KACP,kBAAC,EAAAC,QAAO,CAACC,OAAK,KAzEf/F,EAiEC,kBAACvD,EAAA,EAAe,CACdC,MAAO0D,EAAE,qCACTzD,KAAMyD,EAAE,oCACRxD,QAAM,IAnERqE,GACAF,GACAtC,GACE,kBAAC,EAAAuH,MAAK,CACJC,UAAW7F,EAAE,2BACb8F,mBACE,kBAAC,EAAAC,sBAAqB,CACpB1D,OAAQ,SAAC,G,IAAEvE,EAAK,QAAO,OAAGA,EAAMmE,KAAI,KAAKnE,EAAM6G,GAC/CqB,wBAAsB,IAG1BC,eAAe,cACfC,gBACE,kBAAC,EAAAC,YAAW,CACVC,YAAa,aACbxI,KAAM+C,EACNY,YAAaA,IAGjB8E,OAAQ,IACRC,QAAS,CACPC,OAAQ,IACRC,KAAM,GACNC,MAAO,GACPC,IAAK,IAEPC,WAAY,EAAAC,gBAAA,eACZnG,MAAOA,EACPoG,UAAW,CAAElC,EAAG,GAChBmC,iBAAiB,GAEjB,kBAAC,EAAAC,UAAS,CAACC,MAAO,SAAeC,UAAW,IAC5C,kBAAC,EAAAF,UAAS,CACRG,eAAa,EACbC,WAAY,SAACnH,GAAM,OAAG1B,KAAKC,MAAMyB,GAAE,IAAI3B,GACvC4I,UAAW,IAEb,kBAAC,EAAAG,WAAU,KACRvG,EAAUhD,KAAI,SAACI,EAAOmE,GAAU,OAC/B,kBAAC,EAAAiF,UAAS,CACRC,IAAK,cAAclF,EACnBxE,KAAMK,EAAM+F,KACZuD,cAAc,YACdC,MAAO,CACL5J,KAAM,UAQd,kBAAC,EAAA6J,eAAc,CACbH,IAAK,kBACL1J,KAAMiD,EAAU,GAAGoD,UACnBuD,MAAO,CACL5J,KAAM,CACJ8J,OAAQ7G,EAAU,GAAGkD,wB,WCnQhC4D,EAA8D,SAAC,G,IAC1EhI,EAAO,UACPC,EAAsB,yBACtBC,EAAyB,4BACzBlD,EAAa,gBAELqD,GAAM,IAAAC,kBAAgB,EACxBC,GAAO,IAAAC,WAEQC,KADL,IAAAC,cAAe,IAAE,KACQ,IAAE,YACnCC,IAAa,IAAAC,aAAc,IAAE,SAC/BT,GAAe,IAAAC,UACf,GAAoB,IAAAS,YAAnBC,EAAK,KAAEC,EAAQ,KAChB,GAAkC,IAAAF,UAAS,GAA1C/B,EAAY,KAAEyC,EAAe,KAC9B,GAAkC,IAAAV,UAAS,IAA1CpB,EAAY,KAAE+B,EAAe,KAC9B,GAAoC,IAAAX,WAA2B,GAA9DoH,EAAa,KAAEC,EAAgB,KAChC,GAAwC,IAAArH,WAAkB,GAAzDsH,EAAe,KAAEC,EAAkB,KAEpC3G,EAAe,WACnB,OAAAtB,EAAauB,SAAWX,EAASZ,EAAauB,QAAQC,cAClDC,EAAcd,GAASA,EAAQ,IAAM,EAAI,GAE/C,IAAA2C,YAAU,WACRhC,IACAiC,OAAOC,iBAAiB,SAAUlC,KACjC,CAACX,IAEE,OAA4B,IAAAD,YAA3BK,EAAS,KAAEC,EAAY,KACxB,GAAsB,IAAAN,YAArBG,EAAM,KAAEC,EAAS,KAClB,GAAwC,IAAAJ,YAAvCnC,EAAe,KAAE4C,GAAkB,KACpC,IAA0B,IAAAT,YAAzB/D,GAAQ,MAAEuL,GAAW,MACtB,IAA0C,IAAAxH,WAAS,GAAlDO,GAAgB,MAAEC,GAAmB,MACtC,IAA4B,IAAAR,UAAmB,IAA9CyH,GAAS,MAAEC,GAAY,MAExBC,GAAiB,kE,2FACD,SAAMjI,MAAAA,OAAI,EAAJA,EAAMuB,IAAIC,Y,eAChBC,KADdC,EAAc,WAC6B,KAAhBA,EAA7B,Y,iBASA,O,sBAPMC,EAAc,IAAI,EAAAC,WACtB,IAAI,EAAAC,cAAc,CAChBH,YAAW,EACXxB,SAAQ,KAIPT,EAGQ,GAAMkC,EAAYG,uBAC7BrC,EACe,GAAflB,EACe,GAAfW,EACA,CACE,iDACA,qDARF,I,cAEIxB,EAAO,SAUP,EAAiB,CACrBqE,KAAM,uBACNmG,QAAS,IAAIC,KAGT,EAAiB,CACrBpG,KAAM,uBACNmG,QAAS,IAAIC,KAGXzK,EAAKA,KAAKsE,OACZrC,GAA0B,GAEX,QAAf,EAAAjC,EAAKA,KAAKsE,aAAK,SAAElE,SAAQ,SAACmE,EAAMC,G,QACxBC,EAASF,EAAKG,OACpB,QAAeX,IAAXU,EACF,MAAM,IAAIE,MAAM,mCAElB,QAAoBZ,IAAhBQ,EAAKK,OACP,MAAM,IAAID,MAAM,mCAII,qBAApBF,EAAc,OACM,uBAApBA,EAAc,OAEd4F,IACE5F,EAAc,QAC0B,IAAxC4F,GAAUK,QAAQjG,EAAc,QAChC6F,IAAa,0CAAID,IAAW,GAAF,CAAE5F,EAAc,QAAC,KAGxByF,EACC,qBAApBzF,EAAc,OACM,uBAApBA,EAAc,OACduF,IAAkBvF,EAAc,MACZ,qBAApBA,EAAc,OACM,uBAApBA,EAAc,SAKd,mDADAA,EAAiB,WAGN,QAAX,EAAAF,EAAKK,cAAM,SAAExE,SAAQ,SAACC,EAAOyE,G,MAC3B,GAAuBf,MAAnB1D,EAAM0E,UACR,MAAM,IAAIJ,MAAM,iCAEd,EAAe6F,QAAQG,IAAItK,EAAM0E,WAEZ,QADvB,IAAeyF,QACZI,IAAIvK,EAAM0E,kBAAU,SACnBI,KAAK9E,EAAMA,OAEf,EAAemK,QAAQK,IAAIxK,EAAM0E,UAAW,CAC1C1E,EAAMA,YAOZ,oDADAoE,EAAiB,WAGN,QAAX,EAAAF,EAAKK,cAAM,SAAExE,SAAQ,SAACC,EAAOyE,G,MAC3B,GAAuBf,MAAnB1D,EAAM0E,UACR,MAAM,IAAIJ,MAAM,iCAEd,EAAe6F,QAAQG,IAAItK,EAAM0E,WAEZ,QADvB,IAAeyF,QACZI,IAAIvK,EAAM0E,kBAAU,SACnBI,KAAK9E,EAAMA,OAEf,EAAemK,QAAQK,IAAIxK,EAAM0E,UAAW,CAC1C1E,EAAMA,gBAShB,EAAemK,QAAQjL,KAAO,GAC9B,EAAeiL,QAAQjL,KAAO,GAE9B6K,IAAY,GACZhH,IAAoB,KAEd,EAAkB,GACxB,EAAeoH,QAAQpK,SAAQ,SAACC,EAAOqJ,GACrC,SAAgBvE,KAAK,CAAEJ,UAAW2E,EAAKvJ,MAAOE,OAEhD,EAAeN,WAAa,EAAgB+K,MAC1C,SAAC5D,EAAGC,GAAM,OAAAD,EAAEnC,UAAYoC,EAAEpC,aAEtB,EAAkB,GACxB,EAAeyF,QAAQpK,SAAQ,SAACC,EAAOqJ,GACrC,SAAgBvE,KAAK,CAAEJ,UAAW2E,EAAKvJ,MAAOE,OAEhD,EAAeN,WAAa,EAAgB+K,MAC1C,SAAC5D,EAAGC,GAAM,OAAAD,EAAEnC,UAAYoC,EAAEpC,aAE5BK,GAAa,EAAgB,MAG/BnD,GAA0B,GAC1BmB,IAAoB,I,+BAGlBiC,OAAM,GACN,QAAkB,KACpBA,EAAuB,QAAd,IAAMC,gBAAQ,eAAEtF,KAAKqF,QAEhC3C,GACEA,EAAS,CACPzD,QAAS,EAAAsG,aAAA,OACT7G,MAAO0D,EAAE,+BACTV,YAAa2D,I,gCAMvB,IAAAG,YAAU,WACR+E,OACC,CAAC1J,EAAcW,IAIlB,IAAM4D,GAAe,SACnB2F,EACAC,GAEA,IAAMpF,EAAgC,GAChC3C,EAA8B,GAC9BxC,EAAkBd,EACtBoL,EACAC,GAIF,GAAID,EAAoB,CACtB,IAAM,EAA8B,GAC9BE,EAAQhF,EAAA,SAURO,EAAe,KARfF,EAAyB,WAM7B,OAJEyE,EAAmBhL,WACjBgL,EAAmBhL,WAAWwG,OAAS,GACvCxB,UAAYgG,EAAmBhL,WAAW,GAAGgF,WACjB,IAAO,OAInC0B,GAAwB,IAASH,KAA4B,EAEnE,GAAIE,GAAgB,KAAO3F,GAAgB,EACzC,IAAK,IAAI6F,EAAI,EAAGA,EAAID,EAAsBC,GAAQ,EAAG,CACnD,IAAMC,EACJoE,EAAmBhL,WAAW,GAAGgF,UACJ,KAA5B0B,EAAuBC,GACpB3F,EAAO,IAAI6F,KAAKD,GAChBE,EAAO/F,EAAiBC,EAAM,CAClCC,SAAUJ,EAAeC,KAE3B,EAAKsE,KAAK,CAAEd,KAAM0G,EAAmB1G,KAAMyC,EAAGD,EAAME,EAAG,IAI3DgE,EAAmBhL,WAAWE,KAAI,SAACI,GACjC,IAAMU,EAAO,IAAI6F,KAAKvG,EAAM0E,WACtB8B,EAAO/F,EAAiBC,EAAM,CAClCC,SAAUJ,EAAeC,KAErBmG,EAAiB3G,EAAMF,MAAM8G,QAAO,SAAUC,EAAGC,GACrD,OAAOD,EAAIC,IACV,GACGhH,EAAQK,EAAuBwG,EAAgBvG,GACrD,EAAK0E,KAAK,CAAEd,KAAM0G,EAAmB1G,KAAMyC,EAAGD,EAAME,EAAG5G,OAGzD8C,EAAUkC,KAAK,CAAE8F,MAAK,EAAEC,KAAI,IAE5BtF,EAAWT,KAAK,CACdd,KAAM0G,EAAmB1G,KACzBwB,OAAQ,CACNC,KAAMG,EAAA,YAMZ,GAAI+E,EAAoB,CACtB,IAGM1E,EAHA,EAA8B,GAC9B2E,EAAQE,EAAA,SAUR3E,EAAe,KARfF,EAAyB,WAM7B,OAJE0E,EAAmBjL,WACjBiL,EAAmBjL,WAAWwG,OAAS,GACvCxB,UAAYiG,EAAmBjL,WAAW,GAAGgF,WACjB,IAAO,OAInC0B,GAAwB,IAASH,KAA4B,EAEnE,GAAIE,GAAgB,KAAO3F,GAAgB,EACzC,IAAS6F,EAAI,EAAGA,EAAID,EAAsBC,GAAQ,EAAG,CAC7CC,EACJqE,EAAmBjL,WAAW,GAAGgF,UACJ,KAA5B0B,EAAuBC,GACpB3F,EAAO,IAAI6F,KAAKD,GAChBE,EAAO/F,EAAiBC,EAAM,CAClCC,SAAUJ,EAAeC,KAE3B,EAAKsE,KAAK,CAAEd,KAAM2G,EAAmB3G,KAAMyC,EAAGD,EAAME,EAAG,IAI3DiE,EAAmBjL,WAAWE,KAAI,SAACI,GACjC,IAAMU,EAAO,IAAI6F,KAAKvG,EAAM0E,WACtB8B,EAAO/F,EAAiBC,EAAM,CAClCC,SAAUJ,EAAeC,KAErBmG,EAAiB3G,EAAMF,MAAM8G,QAAO,SAAUC,EAAGC,GACrD,OAAOD,EAAIC,IACV,GACGhH,EAAQK,EAAuBwG,EAAgBvG,GACrD,EAAK0E,KAAK,CAAEd,KAAM2G,EAAmB3G,KAAMyC,EAAGD,EAAME,EAAG5G,OAEzD8C,EAAUkC,KAAK,CAAE8F,MAAK,EAAEC,KAAI,IAC5BtF,EAAWT,KAAK,CACdd,KAAM2G,EAAmB3G,KACzBwB,OAAQ,CACNC,KAAMqF,EAAA,YAIZnI,EAAU4C,GACV1C,EAAaD,GACbI,GAAmB5C,GACnB2C,IAAoB,IAOtB,OACE,kBAAC,EAAAgE,KAAI,KACH,kBAACC,EAAY,CACXC,iBAAiB,EACjB5I,MAAO0D,EAAE,yBACTkB,gBAAiBA,EACjBC,gBAAiBA,EACjB6H,kBAAmBvM,KAAamD,EAChCgI,cAAeA,EACfC,iBAAkBA,EAClBoB,sBAdwB,WAC5Bd,MAcIF,UAAWA,GACXF,mBAAoBA,IAEtB,kBAAC,EAAA1C,UAAS,CAACC,UAAU,MAClBtF,EAAE,uBAAwB,IAC3B,kBAACX,EAAY,CACX/C,MAAO0D,EAAE,uBACTV,YAAaU,EAAE,sCAGnB,kBAAC,EAAAuF,SAAQ,KACP,yBAAKC,IAAK1F,GACR,6BACIiB,GAgGA,kBAAC,EAAA0E,SAAQ,KACP,kBAAC,EAAAC,QAAO,CAACC,OAAK,KAhGf/F,EAwFC,kBAACvD,EAAA,EAAe,CACdC,MAAO0D,EAAE,qCACTzD,KAAMyD,EAAE,oCACRxD,QAAM,IA1FPC,GA+EC,kBAACJ,EAAA,EAAe,CACdC,MAAO0D,EAAE,uCACTzD,KAAMyD,EAAE,sCACRvD,UAAQ,EACRE,cAAeA,IAlFjBkE,GACAF,GACAtC,GACE,oCACE,kBAAC,EAAAuH,MAAK,CACJC,UAAW7F,EAAE,uBACb8F,mBACE,kBAAC,EAAAC,sBAAqB,CACpB1D,OAAQ,SAAC,G,IAAEvE,EAAK,QAAO,OAAGA,EAAMmE,KAAI,KAAKnE,EAAM6G,GAC/CqB,wBAAsB,IAG1Bc,iBAAiB,EACjBb,eAAe,cACfC,gBACE,kBAAC,EAAAC,YAAW,CACVvI,KAAM+C,EACNY,YAAaA,IAGjB8E,OAAQ,IACRC,QAAS,CACPC,OAAQ,IACRC,KAAM,GACNC,MAAO,GACPC,IAAK,IAEPC,WAAY,EAAAC,gBAAA,eACZnG,MAAOA,GAEP,kBAAC,EAAAsG,UAAS,CAACC,MAAO,SAAeC,UAAW,IAC5C,kBAAC,EAAAF,UAAS,CACRG,eAAa,EACbC,WAAY,SAACnH,GACX,OAAG1B,KAAKC,MAAMyB,GAAE,IAAI3B,GAEtB4I,UAAW,EACXJ,UAAW,CAAElC,EAAG,KAElB,kBAAC,EAAAyC,WAAU,KACRvG,EAAUhD,KAAI,SAACI,EAAOmE,GAAU,OAC/B,kBAAC,EAAA8G,UAAS,CACR5B,IAAK,cAAclF,EACnBxE,KAAMK,EAAM6K,KACZtB,MAAO,CACL5J,KAAM,CACJ8J,OAAQzJ,EAAM4K,eAQ1B,kBAAC,EAAAM,QAAO,MACPvB,EACC,kBAACwB,EAAwB,CACvBzJ,QAASA,EACTlB,aAAcA,EACdW,aAAcA,IAGhB,kBAAC,EAAA4F,KAAI,KACH,kBAAC,EAAAK,UAAS,CAACC,UAAU,MAClBtF,EAAE,iCAEL,kBAAC,EAAAuF,SAAQ,KACP,kBAAClJ,EAAA,EAAe,CACdC,MAAO0D,EAAE,uCACTzD,KAAMyD,EAAE,sCACRtD,UAAQ,IACP,Y,WCzZlB0M,EAAyD,SAAC,G,IACrEzJ,EAAO,UACPlB,EAAY,eACZW,EAAY,eAENU,GAAe,IAAAC,UACbC,GAAM,IAAAC,kBAAgB,EACxBC,GAAO,IAAAC,WAESC,GAClB,IAAAC,aAAW,gBACPC,GAAa,IAAAC,YAAU,SACzB,GAAoB,IAAAC,YAAnBC,EAAK,KAAEC,EAAQ,KAChB,GAAsB,IAAAF,YAArBG,EAAM,KAAEC,EAAS,KAClB,GAA4B,IAAAJ,YAA3BK,EAAS,KAAEC,EAAY,KACxB,GAAwC,IAAAN,YAAvCnC,EAAe,KAAE4C,EAAkB,KACpC,GAAsD,IAAAT,WAAS,GAA9DZ,EAAsB,KAAEC,EAAyB,KAClD,GAA0C,IAAAW,WAAS,GAAlDO,EAAgB,KAAEC,EAAmB,KACtC,GAA0B,IAAAR,YAAzB/D,EAAQ,KAAEuL,EAAW,KAEtBqB,EAAS,CAACC,EAAA,SAA6BzF,EAAA,UAEvCzC,EAAe,WACnB,OAAAtB,EAAauB,SAAWX,EAASZ,EAAauB,QAAQC,cAClDC,EAAcd,GAASA,EAAQ,IAAM,EAAI,GAuG/C,IAAA2C,YAAU,YApGuB,gD,uFACX,SAAMlD,MAAAA,OAAI,EAAJA,EAAMuB,IAAIC,Y,eAChBC,KADdC,EAAc,WAC6B,KAAhBA,EAA7B,Y,iBAQA,O,sBANMC,EAAc,IAAI,EAAAC,WACtB,IAAI,EAAAC,cAAc,CAChBH,YAAW,EACXxB,SAAQ,KAGPT,EAGQ,GAAMkC,EAAYG,uBAC7BrC,EACe,GAAflB,EACe,GAAfW,EACA,CAAC,wBAND,I,cAEIxB,EAAO,SAOP,EAA8B,GAEhCA,EAAKA,KAAKsE,OACZrC,GAA0B,GACX,QAAf,EAAAjC,EAAKA,KAAKsE,aAAK,SAAElE,SAAQ,SAACmE,EAAMmC,G,QACxBiF,EAAwB,QAAZ,EAAApH,MAAAA,OAAI,EAAJA,EAAMG,cAAM,eAAEkH,MAC1BnH,EAASF,EAAKG,OACpB,QAAoBX,IAAhBQ,EAAKG,OACP,MAAM,IAAIC,MAAM,mCAElB,QAAoBZ,IAAhBQ,EAAKK,OACP,MAAM,IAAID,MAAM,mCAGlB,IAAMiH,EAAQ,CACZvH,KAAMsH,EACN3L,KAAM,IAGF6L,EAAiB,EAAeC,MACpC,SAACF,GAAU,OAAAA,EAAMvH,OAASsH,KAGD,uCAAvBlH,EAAiB,WACR,QAAX,EAAAF,EAAKK,cAAM,SAAExE,SAAQ,SAACC,GACpB,GAAuB0D,MAAnB1D,EAAM0E,UACR,MAAM,IAAIJ,MAAM,iCAGdkH,EACF,EAAezL,SAAQ,SAACwL,GAClBA,EAAMvH,OAASsH,GACjBC,EAAM5L,KAAKI,SACT,SAACF,GAAU,OAACA,EAAMC,MAAQD,EAAMC,MAAQE,EAAMA,YAKpDuL,EAAM5L,KAAKmF,KAAK,CACdd,KAAMsH,GAAa,GACnB5G,UAAW1E,EAAM0E,UACjB5E,MAAOE,EAAMA,YAMhBwL,GACH,EAAe1G,KAAKyG,OAIlBG,EAAiB,EAAeC,QACpC,SAACJ,GACC,MAAe,qBAAfA,EAAMvH,MACS,uBAAfuH,EAAMvH,SAGSkC,OAAS,GAC1B6D,GAAY,GAEdhF,EAAa2G,KAEb9J,GAA0B,GAC1BmB,GAAoB,I,+BAGlBiC,OAAM,GACN,QAAkB,KACpBA,EAAuB,QAAd,IAAMC,gBAAQ,eAAEtF,KAAKqF,QAEhC3C,EAAS,CACPzD,QAAS,EAAAsG,aAAA,OACT7G,MAAO0D,EAAE,+BACTV,YAAa2D,I,8BAQnB7B,MACC,CAAChC,EAAcX,KAIlB,IAAA2E,YAAU,WACRhC,IACAiC,OAAOC,iBAAiB,SAAUlC,KACjC,CAACX,IAEJ,IAAMuC,EAAe,SAAC6G,GACpB,IAAMrG,EAAgC,GAChC3C,EAA8B,GAC9BxC,EAAkBd,EAAmBsM,OAAgBlI,GAC3DkI,EAAehM,KAAI,SAACiM,EAAW1H,GAC7B,IAAMyG,EAAQQ,EAAOjH,GACrBoB,EAAWT,KAAK,CACdd,KAAM6H,EAAU7H,OAElB,IAAM+B,EAAkC,GAElCE,EAAyB,WAK7B,OAHE4F,EAAUlM,KAAKkM,EAAUlM,KAAKuG,OAAS,GAAGxB,UAC1CmH,EAAUlM,KAAK,GAAG+E,WACY,IAAO,IAGnCyB,EAAe,IAASF,IACxBG,GAAwB,IAASH,KAA4B,EAEnE,GAAIE,GAAgB,KAAO3F,GAAgB,EACzC,IAAK,IAAI6F,EAAI,EAAGA,EAAID,EAAsBC,GAAQ,EAAG,CACnD,IAAMyF,EACJD,EAAUlM,KAAK,GAAG+E,UACW,KAA5B0B,EAAuBC,GACpB3F,EAAO,IAAI6F,KAAKuF,GAChBtF,EAAO/F,EAAiBC,EAAM,CAClCC,SAAUJ,EAAeC,KAE3BuF,EAAKjB,KAAK,CAAEd,KAAM6H,EAAU7H,KAAMyC,EAAGD,EAAME,EAAG,IAIlDmF,EAAUlM,KAAKC,KAAI,SAACI,GAClB,IAAMU,EAAO,IAAI6F,KAAKvG,EAAM0E,WACtB8B,EAAO/F,EAAiBC,EAAM,CAClCC,SAAUJ,EAAeC,KAErBV,EAAQK,EAAuBH,EAAMF,MAAOM,GAClD2F,EAAKjB,KAAK,CAAEd,KAAMhE,EAAMgE,KAAMyC,EAAGD,EAAME,EAAG5G,OAE5C8C,EAAUkC,KAAK,CAAE8F,MAAK,EAAE7E,KAAI,OAE9BpD,EAAU4C,GACV1C,EAAaD,GACbI,EAAmB5C,GACnB2C,GAAoB,IAGtB,OACE,kBAAC,EAAAgE,KAAI,KACH,kBAAC,EAAAK,UAAS,CAACC,UAAU,MAClBtF,EAAE,kCAAmC,IACtC,kBAACX,EAAY,CACX/C,MAAO0D,EAAE,kCACTV,YAAaU,EAAE,+CAGnB,kBAAC,EAAAuF,SAAQ,KACP,yBAAKC,IAAK1F,GACNiB,EA4DA,kBAAC,EAAA0E,SAAQ,KACP,kBAAC,EAAAC,QAAO,CAACC,OAAK,KA5Df/F,EAoDC,kBAACvD,EAAA,EAAe,CACdC,MAAO0D,EAAE,qCACTzD,KAAMyD,EAAE,oCACRxD,QAAM,IAtDPC,EA4CC,kBAACJ,EAAA,EAAe,CACdC,MAAO0D,EAAE,uCACTzD,KAAMyD,EAAE,sCACRvD,UAAQ,IA9CVoE,GACAF,GACA,KACE,kBAAC,EAAAiF,MAAK,CACJC,UAAW7F,EAAE,kCACb8F,mBACE,kBAAC,EAAAC,sBAAqB,CACpB1D,OAAQ,SAAC,G,IAAEvE,EAAK,QAAO,OAAGA,EAAMmE,KAAI,KAAKnE,EAAM6G,GAC/CqB,wBAAsB,IAG1BC,eAAe,cACfC,gBACE,kBAAC,EAAAC,YAAW,CAACvI,KAAM+C,EAAQY,YAAaA,IAE1C8E,OAAQ,IACRC,QAAS,CACPC,OAAQ,IACRC,KAAM,GACNC,MAAO,GACPC,IAAK,IAEPC,WAAY,EAAAC,gBAAA,eACZnG,MAAOA,EACPqG,iBAAiB,GAEjB,kBAAC,EAAAC,UAAS,CAACC,MAAO,SAAeC,UAAW,IAC5C,kBAAC,EAAAF,UAAS,CACRG,eAAa,EACbC,WAAY,SAACnH,GAAM,OAAG1B,KAAKC,MAAMyB,GAAE,IAAI3B,KAEzC,kBAAC,EAAA+I,WAAU,KACRvG,EAAUhD,KAAI,SAACI,EAAOmE,GAAU,OAC/B,kBAAC,EAAAiF,UAAS,CACRC,IAAK,cAAclF,EACnBxE,KAAMK,EAAM+F,KACZuD,cAAc,uB,qBC7R3ByC,EAAgB,SAAC,G,IAC5BpC,EAAa,gBACbC,EAAgB,mBAChBI,EAAS,YACTF,EAAkB,qBAClBkC,EAAc,iBAER,GAA4C,IAAAzJ,WAAkB,GAA7D0J,EAAiB,KAAEC,EAAoB,KACxC,GAAsC,IAAA3J,YAArC4J,EAAc,KAAEC,EAAiB,MAExC,IAAAjH,YAAU,WACR6E,GAAaoC,EAAkBpC,KAC9B,CAACA,IAEJ,IAmBMqC,EAAe,SAACrC,GAAc,OAClC,kBAAC,EAAAsC,aAAY,CAACjD,IAAK,iBAAkBrJ,MAAM,eAC3C,kBAAC,EAAAuM,YAAW,CAACxD,MAAM,kBAAkBM,IAAI,sBACtCW,MAAAA,OAAS,EAATA,EAAWpK,KAAI,SAAC2L,EAAOpH,GAAU,OAChC,kBAAC,EAAAmI,aAAY,CAACjD,IAAK,iBAAgBlF,EAAQ,GAAKnE,MAAOuL,UAc7D,OACE,kBAAC,EAAAiB,YAAW,CAACC,OAVA,CACbC,QAAS,QACTC,GAAI,OACJC,GAAI,QACJC,GAAI,QACJC,GAAI,QACJ,MAAO,UAKL,kBAAC,EAAAC,OAAM,CACLnO,QAAS,EAAAoO,cAAA,OACTC,SAzCgB,SAAChB,GACrBC,EAAqBD,IAyCjBiB,SAtCgB,SAACC,EAAGjM,GACxB0I,GAAoBA,EAAiB1I,GACrC4I,GAEMA,EADW,eAAd5I,GAGHgL,GAAqB,IAiCjBkB,WAAYzD,EACZ0D,OAAQpB,EACRqB,gBACE,oCACE,kBAAC,KAAU,M,eACV,kBAEY,UACjBC,SAtCgB,SAACJ,EAAGK,GACxB,IAAM9B,GACJS,MAAAA,OAAc,EAAdA,EAAgBR,QAAO,SAACJ,GAAU,OAA6B,GAA7BA,EAAMlB,QAAQmD,QAAqB,GACvE,OAAOnB,EAAaX,IAoChB+B,WAAS,EACTC,iBAAe,EACfC,WAAY3B,EACZzC,MAAO,CAAE/G,MAAO,SAEf6J,EAAaF,MCxETyB,EAAe,SAAC,G,IAC3B3K,EAAe,kBACfC,EAAe,kBACf2K,EAAO,UACP7B,EAAc,iBAER,GAAkC,IAAAzJ,WAAkB,GAAnDuL,EAAY,KAAEC,EAAe,KAC9B,GAA0C,IAAAxL,WAAkB,GAA3DyL,EAAgB,KAAEC,EAAmB,KA2B5C,OACE,kBAAC,EAAAzB,YAAW,KACV,kBAAC,EAAAO,OAAM,CACLnO,QAAS,EAAAoO,cAAA,OAAoB,aAClB,eACXC,SA9Be,SAACe,GACpBC,EAAoBD,IA8BhBd,SA3Be,SAACC,EAAGjM,GACvB+B,EAAgBhC,EAAWC,GAAWV,cACtC0C,EAAgBjC,EAAWC,GAAWC,cACtC4M,EAAgB7M,GAChB+M,GAAoB,IAwBhBb,WAAYU,EACZT,OAAQW,EACRL,WAAY3B,EACZsB,gBAAgB,gBAxBF,SAACO,GAAoB,OACvC,kBAAC,EAAAtB,YAAW,CAACxD,MAAM,uBAAuBM,IAAQwE,EAAO,UACvD,kBAAC,EAAAvB,aAAY,CAACjD,IAAQwE,EAAO,KAAM7N,MAAM,mBACzC,kBAAC,EAAAsM,aAAY,CAACjD,IAAQwE,EAAO,KAAM7N,MAAM,oBACzC,kBAAC,EAAAsM,aAAY,CAACjD,IAAQwE,EAAO,KAAM7N,MAAM,oBACzC,kBAAC,EAAAsM,aAAY,CAACjD,IAAQwE,EAAO,KAAM7N,MAAM,gBACzC,kBAAC,EAAAsM,aAAY,CAACjD,IAAQwE,EAAO,KAAM7N,MAAM,iBACzC,kBAAC,EAAAsM,aAAY,CAACjD,IAAQwE,EAAO,KAAM7N,MAAM,iBACzC,kBAAC,EAAAsM,aAAY,CAACjD,IAAQwE,EAAO,KAAM7N,MAAM,kBACzC,kBAAC,EAAAsM,aAAY,CAACjD,IAAQwE,EAAO,KAAM7N,MAAM,kBACzC,kBAAC,EAAAsM,aAAY,CAACjD,IAAQwE,EAAO,KAAM7N,MAAM,gBACzC,kBAAC,EAAAsM,aAAY,CAACjD,IAAQwE,EAAO,KAAM7N,MAAM,kBAetCkO,CAAYL,MCnCR7G,EAAe,SAAC,G,IAC3B3I,EAAK,QACL4I,EAAe,kBACfhE,EAAe,kBACfC,EAAe,kBACf,IAAAgE,iBAAAA,OAAgB,IAAG,GAAI,EACvB,IAAA6D,iBAAAA,OAAgB,IAAG,GAAI,EACvBnB,EAAgB,mBAChBD,EAAa,gBACbxC,EAAqB,wBACrB6D,EAAqB,wBACrBhB,EAAS,YACTF,EAAkB,qBAElB,OACE,oCACE,kBAAC,EAAAqE,MAAK,KACJ,kBAAC,EAAAC,UAAS,KACR,kBAAC,EAAAhH,UAAS,CAACC,UAAU,MAAMhJ,IAE7B,kBAAC,EAAA+P,UAAS,KACPnH,EACC,kBAAC,EAAAoH,QAAO,KACN,kBAAC,EAAAC,eAAc,KACb,kBAACvC,EAAa,CACZpC,cAAeA,EACfC,iBAAkBA,EAClBI,UAAWA,EACXF,mBAAoBA,EACpBkC,gBAAiBjB,IAEnB,kBAAC6C,EAAY,CACX3K,gBAAiBA,EACjBC,gBAAiBA,EACjB8I,gBAAiBjB,EACjB8C,QAAS,8BAEX,kBAAC,EAAAzO,OAAM,CACLR,QAAQ,QAAO,aACJ,OACXS,QAAS2L,GAET,kBAAC,KAAQ,SAKf,kBAAC,EAAAqD,QAAO,KACN,kBAAC,EAAAC,eAAc,KACb,kBAACV,EAAY,CACX3K,gBAAiBA,EACjBC,gBAAiBA,EACjB2K,QAAS,4BACT7B,gBAAiB9E,IAEnB,kBAAC,EAAA9H,OAAM,CACLR,QAAQ,QAAO,aACJ,OACXS,QAAS8H,GAET,kBAAC,KAAQ,WAOrB,kBAAC,EAAA+D,QAAO","sources":["webpack://kas-ui/./src/app/modules/Metrics/components/ChartEmptyState/ChartEmptyState.tsx","webpack://kas-ui/./src/app/modules/Metrics/utils/utils.ts","webpack://kas-ui/./src/app/modules/Metrics/components/ChartPopover/ChartPopover.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/UsedDiskSpaceChart/UsedDiskSpaceChart.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/IncomingOutgoingBytesPerTopic/IncomingOutgoingBytesPerTopic.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/LogSizePerPartitionChart/LogSizePerPartitionChart.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ChartToolbar/FilterByTopic.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ChartToolbar/FilterByTime.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ChartToolbar/ChartToolbar.tsx"],"sourcesContent":["import React from 'react';\nimport {\n  EmptyState,\n  EmptyStateVariant,\n  EmptyStateBody,\n  EmptyStateIcon,\n  Title,\n  Button,\n} from '@patternfly/react-core';\nimport TachometerAltIcon from '@patternfly/react-icons/dist/js/icons/tachometer-alt-icon';\nimport WrenchIcon from '@patternfly/react-icons/dist/js/icons/wrench-icon';\nimport FilterIcon from '@patternfly/react-icons/dist/js/icons/filter-icon';\n\ntype ChartEmptyState = {\n  title: string;\n  body: string;\n  noData?: boolean;\n  noTopics?: boolean;\n  noFilter?: boolean;\n  onCreateTopic?: () => void;\n};\n\nexport const ChartEmptyState = ({\n  title,\n  body,\n  noData,\n  noTopics,\n  noFilter,\n  onCreateTopic,\n}: ChartEmptyState) => {\n  const getIcon = () => {\n    if (noData) {\n      return TachometerAltIcon;\n    } else if (noTopics) {\n      return WrenchIcon;\n    } else if (noFilter) {\n      return FilterIcon;\n    }\n    return;\n  };\n\n  return (\n    <EmptyState variant={EmptyStateVariant.xs}>\n      <EmptyStateIcon icon={getIcon()} />\n      <Title headingLevel='h3' size='lg'>\n        {title}\n      </Title>\n      <EmptyStateBody>\n        {body}\n        <br />\n        <br />\n        {noTopics && (\n          <Button variant='primary' onClick={onCreateTopic}>\n            Create topic\n          </Button>\n        )}\n      </EmptyStateBody>\n    </EmptyState>\n  );\n};\n","import byteSize from 'byte-size';\n\nexport const getLargestByteSize = (data1, data2) => {\n  let currentByteSize = 'B';\n\n  data1 = data1 && (data1.sortedData ? data1.sortedData : data1.data);\n  data2 = data2 && (data2.sortedData ? data2.sortedData : data2.data);\n\n  data1 &&\n    data1.map((datum) => {\n      datum.bytes.forEach((value) => {\n        const byteString = byteSize(value).unit;\n        if (byteString === 'kiB') {\n          if (currentByteSize === 'B') {\n            currentByteSize = 'kiB';\n          }\n        }\n        if (byteString === 'MiB') {\n          if (currentByteSize === 'B' || currentByteSize === 'kiB') {\n            currentByteSize = 'MiB';\n          }\n        }\n        if (byteString === 'GiB') {\n          if (\n            currentByteSize === 'B' ||\n            currentByteSize === 'kiB' ||\n            currentByteSize === 'MiB'\n          ) {\n            currentByteSize = 'GiB';\n          }\n        }\n      });\n    });\n\n  data2 &&\n    data2.map((datum) => {\n      datum.bytes.forEach((value) => {\n        const byteString = byteSize(value).unit;\n        if (byteString === 'kiB') {\n          if (currentByteSize === 'B') {\n            currentByteSize = 'kiB';\n          }\n        }\n        if (byteString === 'MiB') {\n          if (currentByteSize === 'B' || currentByteSize === 'kiB') {\n            currentByteSize = 'MiB';\n          }\n        }\n        if (byteString === 'GiB') {\n          if (\n            currentByteSize === 'B' ||\n            currentByteSize === 'kiB' ||\n            currentByteSize === 'MiB'\n          ) {\n            currentByteSize = 'GiB';\n          }\n        }\n      });\n    });\n\n  return currentByteSize;\n};\n\nexport const convertToSpecifiedByte = (\n  bytes: number,\n  largestByteSize: 'B' | 'kiB' | 'MiB' | 'GiB'\n): number => {\n  if (largestByteSize === 'B') {\n    return Math.round(bytes * 10) / 10;\n  }\n  if (largestByteSize === 'kiB') {\n    return Math.round((bytes / 1024) * 10) / 10;\n  }\n  if (largestByteSize === 'MiB') {\n    return Math.round((bytes / 1024 / 1024) * 10) / 10;\n  }\n  if (largestByteSize === 'GiB') {\n    return Math.round((bytes / 1024 / 1024 / 1024) * 10) / 10;\n  }\n  return bytes;\n};\n\nexport const shouldShowDate = (timeDuration) => {\n  return timeDuration >= 24 ? true : false;\n};\n\nexport const dateToChartValue = (date, { showDate }) => {\n  const [dateValue, timeValue] = date.toISOString().split('T');\n  return showDate\n    ? timeValue.slice(0, 5) + '\\n' + dateValue\n    : timeValue.slice(0, 5);\n};\nexport const getMaxValueOfArray = (data) => {\n  const max = data.reduce(function (prev, current) {\n    return prev.bytes > current.bytes ? prev : current;\n  });\n  return max.bytes;\n};\n\n//Add a scalable logic to set duration and interval\nexport const formatTime = (selection: string) => {\n  let timeDuration = 6;\n  let timeInterval = 1 * 60; //in minutes\n  switch (selection) {\n    case 'Last 5 minutes':\n      timeDuration = 5 / 60;\n      timeInterval = 1;\n      break;\n    case 'Last 15 minutes':\n      timeDuration = 15 / 60;\n      timeInterval = 3;\n      break;\n    case 'Last 30 minutes':\n      timeDuration = 30 / 60;\n      timeInterval = 5;\n      break;\n    case 'Last 1 hour':\n      timeDuration = 1;\n      timeInterval = 10;\n      break;\n    case 'Last 3 hours':\n      timeDuration = 3;\n      timeInterval = 30;\n      break;\n    case 'Last 6 hours':\n      timeDuration = 6;\n      timeInterval = 1 * 60;\n      break;\n    case 'Last 12 hours':\n      timeDuration = 12;\n      timeInterval = 2 * 60;\n      break;\n    case 'Last 24 hours':\n      timeDuration = 24;\n      timeInterval = 4 * 60;\n      break;\n    case 'Last 2 days':\n      timeDuration = 2 * 24;\n      timeInterval = 8 * 60;\n      break;\n    case 'Last 7 days':\n      timeDuration = 7 * 24;\n      timeInterval = 24 * 60;\n      break;\n  }\n  return { timeDuration, timeInterval };\n};\n","import { Popover } from '@patternfly/react-core';\nimport OutlinedQuestionCircleIcon from '@patternfly/react-icons/dist/js/icons/outlined-question-circle-icon';\nimport React from 'react';\n\ntype ChartPopoverProps = {\n  title: string;\n  description: string;\n};\n\nexport const ChartPopover = ({ title, description }: ChartPopoverProps) => {\n  return (\n    <Popover\n      aria-label='Basic popover'\n      headerContent={<div>{title}</div>}\n      bodyContent={<div>{description}</div>}\n    >\n      <OutlinedQuestionCircleIcon />\n    </Popover>\n  );\n};\n","import React, { useState, useEffect, useRef } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Configuration, DefaultApi } from '@rhoas/kafka-management-sdk';\nimport { useAlert, useAuth, useConfig } from '@rhoas/app-services-ui-shared';\nimport { isServiceApiError } from '@app/utils';\nimport {\n  AlertVariant,\n  Bullseye,\n  Card,\n  CardTitle,\n  CardBody,\n  Spinner,\n} from '@patternfly/react-core';\nimport {\n  Chart,\n  ChartArea,\n  ChartAxis,\n  ChartGroup,\n  ChartLegend,\n  ChartThemeColor,\n  ChartThreshold,\n  ChartVoronoiContainer,\n} from '@patternfly/react-charts';\nimport chart_color_blue_300 from '@patternfly/react-tokens/dist/js/chart_color_blue_300';\nimport chart_color_black_500 from '@patternfly/react-tokens/dist/js/chart_color_black_500';\nimport { ChartEmptyState, ChartToolbar } from '@app/modules/Metrics/components';\nimport {\n  convertToSpecifiedByte,\n  dateToChartValue,\n  shouldShowDate,\n} from '@app/modules/Metrics/utils';\nimport { ChartPopover } from '../ChartPopover';\n\ntype Broker = {\n  name: string;\n  data: {\n    timestamp: number;\n    usedSpaceAvg: number[];\n  }[];\n};\n\ntype ChartData = {\n  areaColor: string;\n  softLimitColor: string;\n  area: BrokerChartData[];\n  softLimit: BrokerChartData[];\n};\n\ntype BrokerChartData = {\n  name: string;\n  x: string;\n  y: number;\n};\n\ntype LegendData = {\n  name: string;\n  symbol: any;\n};\n\ntype KafkaInstanceProps = {\n  kafkaID: string;\n  metricsDataUnavailable: boolean;\n  setMetricsDataUnavailable: (value: boolean) => void;\n};\n\nexport const UsedDiskSpaceChart: React.FC<KafkaInstanceProps> = ({\n  kafkaID,\n  metricsDataUnavailable,\n  setMetricsDataUnavailable,\n}: KafkaInstanceProps) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const { t } = useTranslation();\n  const auth = useAuth();\n  const { kas } = useConfig() || {};\n  const { apiBasePath: basePath } = kas || {};\n  const { addAlert } = useAlert() || {};\n  const [width, setWidth] = useState<number>();\n  const [legend, setLegend] = useState<LegendData[]>();\n  const [chartData, setChartData] = useState<ChartData[]>();\n  const [chartDataLoading, setChartDataLoading] = useState(true);\n  const [largestByteSize, setLargestByteSize] = useState<string>();\n  const [timeDuration, setTimeDuration] = useState(6);\n  const [timeInterval, setTimeInterval] = useState(60);\n  const usageLimit = 60; // Replace with limit from API\n\n  const handleResize = () =>\n    containerRef.current && setWidth(containerRef.current.clientWidth);\n  const itemsPerRow = width && width > 650 ? 6 : 3;\n\n  const fetchUsedDiskSpaceMetrics = async () => {\n    const accessToken = await auth?.kas.getToken();\n    if (accessToken !== undefined && accessToken !== '') {\n      try {\n        const apisService = new DefaultApi(\n          new Configuration({\n            accessToken,\n            basePath,\n          })\n        );\n        if (!kafkaID) {\n          return;\n        }\n\n        const data = await apisService.getMetricsByRangeQuery(\n          kafkaID,\n          timeDuration * 60,\n          timeInterval * 60,\n          ['kubelet_volume_stats_used_bytes']\n        );\n\n        const avgBroker = {\n          name: `Used disk space`,\n          data: [],\n        } as Broker;\n\n        if (data.data.items) {\n          setMetricsDataUnavailable(false);\n          data.data.items?.forEach((item, index) => {\n            const labels = item.metric;\n\n            if (labels === undefined) {\n              throw new Error('item.metric cannot be undefined');\n            }\n            if (item.values === undefined) {\n              throw new Error('item.values cannot be undefined');\n            }\n            if (labels['__name__'] === 'kubelet_volume_stats_used_bytes') {\n              const pvcName = labels['persistentvolumeclaim'];\n\n              if (!pvcName.includes('zookeeper')) {\n                item.values?.forEach((value, indexJ) => {\n                  if (value.timestamp == undefined) {\n                    throw new Error('timestamp cannot be undefined');\n                  }\n\n                  if (index > 0) {\n                    const newArray = avgBroker.data[indexJ].usedSpaceAvg.concat(\n                      value.value\n                    );\n                    avgBroker.data[indexJ].usedSpaceAvg = newArray;\n                  } else {\n                    avgBroker.data.push({\n                      timestamp: value.timestamp,\n                      usedSpaceAvg: [value.value],\n                    });\n                  }\n                });\n              }\n            }\n\n            getChartData(avgBroker);\n          });\n        } else {\n          setMetricsDataUnavailable(true);\n          setChartDataLoading(false);\n        }\n      } catch (error) {\n        let reason: string | undefined;\n        if (isServiceApiError(error)) {\n          reason = error.response?.data.reason;\n        }\n        addAlert &&\n          addAlert({\n            variant: AlertVariant.danger,\n            title: t('common.something_went_wrong'),\n            description: reason,\n          });\n      }\n    }\n  };\n\n  useEffect(() => {\n    fetchUsedDiskSpaceMetrics();\n    handleResize();\n  }, [timeDuration, timeInterval]);\n\n  // useTimeout(() => fetchUsedDiskSpaceMetrics(), 1000 * 60 * 5);\n\n  useEffect(() => {\n    handleResize();\n    window.addEventListener('resize', handleResize);\n  }, [width]);\n\n  const getChartData = (avgBroker) => {\n    const legendData: Array<LegendData> = [\n      {\n        name: 'Limit',\n        symbol: { fill: chart_color_black_500.value, type: 'threshold' },\n      },\n      { name: avgBroker.name, symbol: { fill: chart_color_blue_300.value } },\n    ];\n\n    const areaColor = chart_color_blue_300.value;\n    const softLimitColor = chart_color_black_500.value;\n    const chartData: Array<ChartData> = [];\n    const area: Array<BrokerChartData> = [];\n    const softLimit: Array<BrokerChartData> = [];\n    const largestByteSize = 'GiB'; // Hard code GiB as the largest byte size because there will always be a 20 GiB limit.\n\n    const getCurrentLengthOfData = () => {\n      const timestampDiff =\n        avgBroker.data[avgBroker.data.length - 1].timestamp -\n        avgBroker.data[0].timestamp;\n      const minutes = timestampDiff / 1000 / 60;\n      return minutes;\n    };\n\n    const lengthOfData = 6 * 60 - getCurrentLengthOfData();\n    const lengthOfDataPer5Mins = (6 * 60 - getCurrentLengthOfData()) / 5;\n\n    if (lengthOfData <= 360 && timeDuration >= 6) {\n      for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n        const newTimestamp =\n          avgBroker.data[0].timestamp -\n          (lengthOfDataPer5Mins - i) * (5 * 60000);\n        const date = new Date(newTimestamp);\n        const time = dateToChartValue(date, {\n          showDate: shouldShowDate(timeDuration),\n        });\n        area.push({ name: avgBroker.name, x: time, y: 0 });\n        softLimit.push({ name: 'Limit', x: time, y: usageLimit });\n      }\n    }\n\n    avgBroker.data.map((value) => {\n      const date = new Date(value.timestamp);\n      const time = dateToChartValue(date, {\n        showDate: shouldShowDate(timeDuration),\n      });\n      const aggregateBytes = value.usedSpaceAvg.reduce(function (a, b) {\n        return a + b;\n      }, 0);\n\n      const bytes = convertToSpecifiedByte(aggregateBytes, largestByteSize);\n      area.push({ name: avgBroker.name, x: time, y: bytes });\n      softLimit.push({ name: 'Limit', x: time, y: usageLimit });\n    });\n    chartData.push({ areaColor, softLimitColor, area, softLimit });\n\n    setLegend(legendData);\n    setChartData(chartData);\n    setLargestByteSize(largestByteSize);\n    setChartDataLoading(false);\n  };\n\n  const onRefreshKafkaToolbar = () => {\n    fetchUsedDiskSpaceMetrics();\n  };\n\n  return (\n    <Card>\n      <ChartToolbar\n        showTopicFilter={false}\n        title={t('metrics.kafka_instance_metrics')}\n        setTimeDuration={setTimeDuration}\n        setTimeInterval={setTimeInterval}\n        showKafkaToolbar={!metricsDataUnavailable}\n        onRefreshKafkaToolbar={onRefreshKafkaToolbar}\n      />\n      <CardTitle component='h2'>\n        {t('metrics.used_disk_space')}{' '}\n        <ChartPopover\n          title={t('metrics.used_disk_space')}\n          description={t('metrics.used_disk_space_help_text')}\n        />\n      </CardTitle>\n      <CardBody>\n        <div ref={containerRef}>\n          {!chartDataLoading ? (\n            !metricsDataUnavailable ? (\n              chartData &&\n              legend &&\n              largestByteSize && (\n                <Chart\n                  ariaTitle={t('metrics.used_disk_space')}\n                  containerComponent={\n                    <ChartVoronoiContainer\n                      labels={({ datum }) => `${datum.name}: ${datum.y}`}\n                      constrainToVisibleArea\n                    />\n                  }\n                  legendPosition='bottom-left'\n                  legendComponent={\n                    <ChartLegend\n                      orientation={'horizontal'}\n                      data={legend}\n                      itemsPerRow={itemsPerRow}\n                    />\n                  }\n                  height={350}\n                  padding={{\n                    bottom: 110, // Adjusted to accomodate legend\n                    left: 90,\n                    right: 60,\n                    top: 25,\n                  }}\n                  themeColor={ChartThemeColor.multiUnordered}\n                  width={width}\n                  minDomain={{ y: 0 }}\n                  legendAllowWrap={true}\n                >\n                  <ChartAxis label={'\\n' + 'Time'} tickCount={6} />\n                  <ChartAxis\n                    dependentAxis\n                    tickFormat={(t) => `${Math.round(t)} ${largestByteSize}`}\n                    tickCount={4}\n                  />\n                  <ChartGroup>\n                    {chartData.map((value, index) => (\n                      <ChartArea\n                        key={`chart-area-${index}`}\n                        data={value.area}\n                        interpolation='monotoneX'\n                        style={{\n                          data: {\n                            // TODO: check if this is needed\n                            // stroke: value.color,\n                          },\n                        }}\n                      />\n                    ))}\n                  </ChartGroup>\n                  <ChartThreshold\n                    key={`chart-softlimit`}\n                    data={chartData[0].softLimit}\n                    style={{\n                      data: {\n                        stroke: chartData[0].softLimitColor,\n                      },\n                    }}\n                  />\n                </Chart>\n              )\n            ) : (\n              <ChartEmptyState\n                title={t('metrics.empty_state_no_data_title')}\n                body={t('metrics.empty_state_no_data_body')}\n                noData\n              />\n            )\n          ) : (\n            <Bullseye>\n              <Spinner isSVG />\n            </Bullseye>\n          )}\n        </div>\n      </CardBody>\n    </Card>\n  );\n};\n","import React, { useState, useEffect, useRef } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Configuration, DefaultApi } from '@rhoas/kafka-management-sdk';\nimport { useAlert, useAuth, useConfig } from '@rhoas/app-services-ui-shared';\nimport { isServiceApiError } from '@app/utils';\nimport { AlertVariant, Divider } from '@patternfly/react-core';\nimport chart_color_blue_300 from '@patternfly/react-tokens/dist/js/chart_color_blue_300';\nimport chart_color_orange_300 from '@patternfly/react-tokens/dist/js/chart_color_orange_300';\nimport {\n  getLargestByteSize,\n  convertToSpecifiedByte,\n  dateToChartValue,\n  shouldShowDate,\n} from '@app/modules/Metrics/utils';\nimport {\n  Bullseye,\n  Card,\n  CardTitle,\n  CardBody,\n  Spinner,\n} from '@patternfly/react-core';\nimport {\n  Chart,\n  ChartLine,\n  ChartAxis,\n  ChartGroup,\n  ChartLegend,\n  ChartThemeColor,\n  ChartVoronoiContainer,\n} from '@patternfly/react-charts';\nimport {\n  ChartEmptyState,\n  ChartPopover,\n  ChartToolbar,\n  LogSizePerPartitionChart,\n} from '@app/modules/Metrics/components';\n\ntype Topic = {\n  name: string;\n  rawData: Map<number, number[]>;\n  sortedData: TopicDataArray;\n};\n\ntype TopicDataArray = { timestamp: number; bytes: number[] }[];\n\ntype ChartData = {\n  color: string;\n  line: TopicChartData[];\n};\n\ntype TopicChartData = {\n  name: string;\n  x: string;\n  y: number;\n};\n\ntype LegendData = {\n  name: string;\n  symbol: any;\n};\n\ntype KafkaInstanceProps = {\n  kafkaID: string;\n  metricsDataUnavailable: boolean;\n  setMetricsDataUnavailable: (value: boolean) => void;\n  onCreateTopic: () => void;\n};\n\nexport const IncomingOutgoingBytesPerTopic: React.FC<KafkaInstanceProps> = ({\n  kafkaID,\n  metricsDataUnavailable,\n  setMetricsDataUnavailable,\n  onCreateTopic,\n}: KafkaInstanceProps) => {\n  const { t } = useTranslation();\n  const auth = useAuth();\n  const { kas } = useConfig() || {};\n  const { apiBasePath: basePath } = kas || {};\n  const { addAlert } = useAlert() || {};\n  const containerRef = useRef();\n  const [width, setWidth] = useState();\n  const [timeDuration, setTimeDuration] = useState(6);\n  const [timeInterval, setTimeInterval] = useState(60);\n  const [selectedTopic, setSelectedTopic] = useState<boolean | string>(false);\n  const [isFilterApplied, setIsFilterApplied] = useState<boolean>(false);\n\n  const handleResize = () =>\n    containerRef.current && setWidth(containerRef.current.clientWidth);\n  const itemsPerRow = width && width > 650 ? 6 : 3;\n\n  useEffect(() => {\n    handleResize();\n    window.addEventListener('resize', handleResize);\n  }, [width]);\n\n  const [chartData, setChartData] = useState<ChartData[]>();\n  const [legend, setLegend] = useState<LegendData[]>();\n  const [largestByteSize, setLargestByteSize] = useState();\n  const [noTopics, setNoTopics] = useState<boolean>();\n  const [chartDataLoading, setChartDataLoading] = useState(true);\n  const [topicList, setTopicList] = useState<string[]>([]);\n\n  const fetchBytesData = async () => {\n    const accessToken = await auth?.kas.getToken();\n    if (accessToken !== undefined && accessToken !== '') {\n      try {\n        const apisService = new DefaultApi(\n          new Configuration({\n            accessToken,\n            basePath,\n          })\n        );\n\n        if (!kafkaID) {\n          return;\n        }\n        const data = await apisService.getMetricsByRangeQuery(\n          kafkaID,\n          timeDuration * 60,\n          timeInterval * 60,\n          [\n            'kafka_server_brokertopicmetrics_bytes_in_total',\n            'kafka_server_brokertopicmetrics_bytes_out_total',\n          ]\n        );\n\n        const incomingTopics = {\n          name: 'Total incoming bytes',\n          rawData: new Map<number, number[]>(),\n        } as Topic;\n\n        const outgoingTopics = {\n          name: 'Total outgoing bytes',\n          rawData: new Map<number, number[]>(),\n        } as Topic;\n\n        if (data.data.items) {\n          setMetricsDataUnavailable(false);\n\n          data.data.items?.forEach((item, index) => {\n            const labels = item.metric;\n            if (labels === undefined) {\n              throw new Error('item.metric cannot be undefined');\n            }\n            if (item.values === undefined) {\n              throw new Error('item.values cannot be undefined');\n            }\n\n            if (\n              labels['topic'] !== '__strimzi_canary' &&\n              labels['topic'] !== '__consumer_offsets'\n            ) {\n              topicList &&\n                labels['topic'] &&\n                topicList.indexOf(labels['topic']) === -1 &&\n                setTopicList([...topicList, labels['topic']]);\n            }\n\n            const isSelectedItem = isFilterApplied\n              ? labels['topic'] !== '__strimzi_canary' &&\n                labels['topic'] !== '__consumer_offsets' &&\n                selectedTopic === labels['topic']\n              : labels['topic'] !== '__strimzi_canary' &&\n                labels['topic'] !== '__consumer_offsets';\n\n            if (isSelectedItem) {\n              if (\n                labels['__name__'] ===\n                'kafka_server_brokertopicmetrics_bytes_in_total'\n              ) {\n                item.values?.forEach((value, indexJ) => {\n                  if (value.timestamp == undefined) {\n                    throw new Error('timestamp cannot be undefined');\n                  }\n                  if (incomingTopics.rawData.has(value.timestamp)) {\n                    incomingTopics.rawData\n                      .get(value.timestamp)\n                      ?.push(value.value);\n                  } else {\n                    incomingTopics.rawData.set(value.timestamp, [\n                      value.value,\n                    ] as number[]);\n                  }\n                });\n              }\n              if (\n                labels['__name__'] ===\n                'kafka_server_brokertopicmetrics_bytes_out_total'\n              ) {\n                item.values?.forEach((value, indexJ) => {\n                  if (value.timestamp == undefined) {\n                    throw new Error('timestamp cannot be undefined');\n                  }\n                  if (outgoingTopics.rawData.has(value.timestamp)) {\n                    outgoingTopics.rawData\n                      .get(value.timestamp)\n                      ?.push(value.value);\n                  } else {\n                    outgoingTopics.rawData.set(value.timestamp, [\n                      value.value,\n                    ] as number[]);\n                  }\n                });\n              }\n            }\n          });\n\n          if (\n            incomingTopics.rawData.size < 1 &&\n            outgoingTopics.rawData.size < 1\n          ) {\n            setNoTopics(true);\n            setChartDataLoading(false);\n          } else {\n            const incomingDataArr = [] as TopicDataArray;\n            incomingTopics.rawData.forEach((value, key) =>\n              incomingDataArr.push({ timestamp: key, bytes: value })\n            );\n            incomingTopics.sortedData = incomingDataArr.sort(\n              (a, b) => a.timestamp - b.timestamp\n            );\n            const outgoingDataArr = [] as TopicDataArray;\n            outgoingTopics.rawData.forEach((value, key) =>\n              outgoingDataArr.push({ timestamp: key, bytes: value })\n            );\n            outgoingTopics.sortedData = outgoingDataArr.sort(\n              (a, b) => a.timestamp - b.timestamp\n            );\n            getChartData(incomingTopics, outgoingTopics);\n          }\n        } else {\n          setMetricsDataUnavailable(true);\n          setChartDataLoading(false);\n        }\n      } catch (error) {\n        let reason: string | undefined;\n        if (isServiceApiError(error)) {\n          reason = error.response?.data.reason;\n        }\n        addAlert &&\n          addAlert({\n            variant: AlertVariant.danger,\n            title: t('common.something_went_wrong'),\n            description: reason,\n          });\n      }\n    }\n  };\n\n  useEffect(() => {\n    fetchBytesData();\n  }, [timeDuration, timeInterval]);\n\n  // useTimeout(() => fetchBytesData(), 1000 * 60 * 5);\n\n  const getChartData = (\n    incomingTopicArray: Topic,\n    outgoingTopicArray: Topic\n  ) => {\n    const legendData: Array<LegendData> = [];\n    const chartData: Array<ChartData> = [];\n    const largestByteSize = getLargestByteSize(\n      incomingTopicArray,\n      outgoingTopicArray\n    );\n\n    // Aggregate of Incoming Bytes per Topic\n    if (incomingTopicArray) {\n      const line: Array<TopicChartData> = [];\n      const color = chart_color_blue_300.value;\n\n      const getCurrentLengthOfData = () => {\n        const timestampDiff =\n          incomingTopicArray.sortedData[\n            incomingTopicArray.sortedData.length - 1\n          ].timestamp - incomingTopicArray.sortedData[0].timestamp;\n        const minutes = timestampDiff / 1000 / 60;\n        return minutes;\n      };\n      const lengthOfData = 6 * 60 - getCurrentLengthOfData();\n      const lengthOfDataPer5Mins = (6 * 60 - getCurrentLengthOfData()) / 5;\n\n      if (lengthOfData <= 360 && timeDuration >= 6) {\n        for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n          const newTimestamp =\n            incomingTopicArray.sortedData[0].timestamp -\n            (lengthOfDataPer5Mins - i) * (5 * 60000);\n          const date = new Date(newTimestamp);\n          const time = dateToChartValue(date, {\n            showDate: shouldShowDate(timeDuration),\n          });\n          line.push({ name: incomingTopicArray.name, x: time, y: 0 });\n        }\n      }\n\n      incomingTopicArray.sortedData.map((value) => {\n        const date = new Date(value.timestamp);\n        const time = dateToChartValue(date, {\n          showDate: shouldShowDate(timeDuration),\n        });\n        const aggregateBytes = value.bytes.reduce(function (a, b) {\n          return a + b;\n        }, 0);\n        const bytes = convertToSpecifiedByte(aggregateBytes, largestByteSize);\n        line.push({ name: incomingTopicArray.name, x: time, y: bytes });\n      });\n\n      chartData.push({ color, line });\n\n      legendData.push({\n        name: incomingTopicArray.name,\n        symbol: {\n          fill: chart_color_blue_300.value,\n        },\n      });\n    }\n\n    // Aggregate of Outgoing Bytes per Topic\n    if (outgoingTopicArray) {\n      const line: Array<TopicChartData> = [];\n      const color = chart_color_orange_300.value;\n\n      const getCurrentLengthOfData = () => {\n        const timestampDiff =\n          outgoingTopicArray.sortedData[\n            outgoingTopicArray.sortedData.length - 1\n          ].timestamp - outgoingTopicArray.sortedData[0].timestamp;\n        const minutes = timestampDiff / 1000 / 60;\n        return minutes;\n      };\n      const lengthOfData = 6 * 60 - getCurrentLengthOfData();\n      const lengthOfDataPer5Mins = (6 * 60 - getCurrentLengthOfData()) / 5;\n\n      if (lengthOfData <= 360 && timeDuration >= 6) {\n        for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n          const newTimestamp =\n            outgoingTopicArray.sortedData[0].timestamp -\n            (lengthOfDataPer5Mins - i) * (5 * 60000);\n          const date = new Date(newTimestamp);\n          const time = dateToChartValue(date, {\n            showDate: shouldShowDate(timeDuration),\n          });\n          line.push({ name: outgoingTopicArray.name, x: time, y: 0 });\n        }\n      }\n\n      outgoingTopicArray.sortedData.map((value) => {\n        const date = new Date(value.timestamp);\n        const time = dateToChartValue(date, {\n          showDate: shouldShowDate(timeDuration),\n        });\n        const aggregateBytes = value.bytes.reduce(function (a, b) {\n          return a + b;\n        }, 0);\n        const bytes = convertToSpecifiedByte(aggregateBytes, largestByteSize);\n        line.push({ name: outgoingTopicArray.name, x: time, y: bytes });\n      });\n      chartData.push({ color, line });\n      legendData.push({\n        name: outgoingTopicArray.name,\n        symbol: {\n          fill: chart_color_orange_300.value,\n        },\n      });\n    }\n    setLegend(legendData);\n    setChartData(chartData);\n    setLargestByteSize(largestByteSize);\n    setChartDataLoading(false);\n  };\n\n  const onRefreshTopicToolbar = () => {\n    fetchBytesData();\n  };\n\n  return (\n    <Card>\n      <ChartToolbar\n        showTopicFilter={true}\n        title={t('metrics.topic_metrics')}\n        setTimeDuration={setTimeDuration}\n        setTimeInterval={setTimeInterval}\n        showTopicToolbar={!noTopics && !metricsDataUnavailable}\n        selectedTopic={selectedTopic}\n        setSelectedTopic={setSelectedTopic}\n        onRefreshTopicToolbar={onRefreshTopicToolbar}\n        topicList={topicList}\n        setIsFilterApplied={setIsFilterApplied}\n      />\n      <CardTitle component='h2'>\n        {t('metrics.total_bytes')}{' '}\n        <ChartPopover\n          title={t('metrics.total_bytes')}\n          description={t('metrics.topic_metrics_help_text')}\n        />\n      </CardTitle>\n      <CardBody>\n        <div ref={containerRef}>\n          <div>\n            {!chartDataLoading ? (\n              !metricsDataUnavailable ? (\n                !noTopics ? (\n                  chartData &&\n                  legend &&\n                  largestByteSize && (\n                    <>\n                      <Chart\n                        ariaTitle={t('metrics.total_bytes')}\n                        containerComponent={\n                          <ChartVoronoiContainer\n                            labels={({ datum }) => `${datum.name}: ${datum.y}`}\n                            constrainToVisibleArea\n                          />\n                        }\n                        legendAllowWrap={true}\n                        legendPosition='bottom-left'\n                        legendComponent={\n                          <ChartLegend\n                            data={legend}\n                            itemsPerRow={itemsPerRow}\n                          />\n                        }\n                        height={300}\n                        padding={{\n                          bottom: 110,\n                          left: 90,\n                          right: 30,\n                          top: 25,\n                        }}\n                        themeColor={ChartThemeColor.multiUnordered}\n                        width={width}\n                      >\n                        <ChartAxis label={'\\n' + 'Time'} tickCount={6} />\n                        <ChartAxis\n                          dependentAxis\n                          tickFormat={(t) =>\n                            `${Math.round(t)} ${largestByteSize}`\n                          }\n                          tickCount={4}\n                          minDomain={{ y: 0 }}\n                        />\n                        <ChartGroup>\n                          {chartData.map((value, index) => (\n                            <ChartLine\n                              key={`chart-line-${index}`}\n                              data={value.line}\n                              style={{\n                                data: {\n                                  stroke: value.color,\n                                },\n                              }}\n                            />\n                          ))}\n                        </ChartGroup>\n                      </Chart>\n\n                      <Divider />\n                      {selectedTopic ? (\n                        <LogSizePerPartitionChart\n                          kafkaID={kafkaID}\n                          timeDuration={timeDuration}\n                          timeInterval={timeInterval}\n                        />\n                      ) : (\n                        <Card>\n                          <CardTitle component='h2'>\n                            {t('metrics.topic_partition_size')}\n                          </CardTitle>\n                          <CardBody>\n                            <ChartEmptyState\n                              title={t('metrics.empty_state_no_filter_title')}\n                              body={t('metrics.empty_state_no_filter_body')}\n                              noFilter\n                            />{' '}\n                          </CardBody>\n                        </Card>\n                      )}\n                    </>\n                  )\n                ) : (\n                  <ChartEmptyState\n                    title={t('metrics.empty_state_no_topics_title')}\n                    body={t('metrics.empty_state_no_topics_body')}\n                    noTopics\n                    onCreateTopic={onCreateTopic}\n                  />\n                )\n              ) : (\n                <ChartEmptyState\n                  title={t('metrics.empty_state_no_data_title')}\n                  body={t('metrics.empty_state_no_data_body')}\n                  noData\n                />\n              )\n            ) : (\n              <Bullseye>\n                <Spinner isSVG />\n              </Bullseye>\n            )}\n          </div>\n        </div>\n      </CardBody>\n    </Card>\n  );\n};\n","import React, { useState, useEffect, useRef } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Configuration, DefaultApi } from '@rhoas/kafka-management-sdk';\nimport { useAlert, useAuth, useConfig } from '@rhoas/app-services-ui-shared';\nimport { isServiceApiError } from '@app/utils';\nimport {\n  AlertVariant,\n  Bullseye,\n  Card,\n  CardTitle,\n  CardBody,\n  Spinner,\n} from '@patternfly/react-core';\nimport {\n  Chart,\n  ChartArea,\n  ChartAxis,\n  ChartGroup,\n  ChartLegend,\n  ChartThemeColor,\n  ChartVoronoiContainer,\n} from '@patternfly/react-charts';\nimport chart_color_blue_300 from '@patternfly/react-tokens/dist/js/chart_color_blue_300';\nimport chart_color_green_300 from '@patternfly/react-tokens/dist/js/chart_color_green_300';\nimport byteSize from 'byte-size';\nimport { ChartEmptyState, ChartPopover } from '@app/modules/Metrics/components';\nimport {\n  getLargestByteSize,\n  convertToSpecifiedByte,\n  dateToChartValue,\n  shouldShowDate,\n} from '@app/modules/Metrics/utils';\nimport { getTime } from 'date-fns';\n\nexport type Partition = {\n  name: string;\n  data: {\n    timestamp: number;\n    bytes: number;\n    name: string;\n  }[];\n};\n\nexport type ChartData = {\n  color: string;\n  area: PartitionChartData[];\n};\n\nexport type PartitionChartData = {\n  name: string;\n  x: string;\n  y: number;\n};\n\nexport type LegendData = {\n  name: string;\n};\n\nexport type KafkaInstanceProps = {\n  kafkaID: string;\n  timeInterval: number;\n  timeDuration: number;\n};\n\nexport const LogSizePerPartitionChart: React.FC<KafkaInstanceProps> = ({\n  kafkaID,\n  timeDuration,\n  timeInterval,\n}: KafkaInstanceProps) => {\n  const containerRef = useRef();\n  const { t } = useTranslation();\n  const auth = useAuth();\n  const {\n    kas: { apiBasePath: basePath },\n  } = useConfig();\n  const { addAlert } = useAlert();\n  const [width, setWidth] = useState<number>();\n  const [legend, setLegend] = useState();\n  const [chartData, setChartData] = useState<ChartData[]>();\n  const [largestByteSize, setLargestByteSize] = useState();\n  const [metricsDataUnavailable, setMetricsDataUnavailable] = useState(false);\n  const [chartDataLoading, setChartDataLoading] = useState(true);\n  const [noTopics, setNoTopics] = useState<boolean>();\n\n  const colors = [chart_color_green_300.value, chart_color_blue_300.value];\n\n  const handleResize = () =>\n    containerRef.current && setWidth(containerRef.current.clientWidth);\n  const itemsPerRow = width && width > 650 ? 6 : 3;\n\n  // Functions\n  const fetchLogSizePerPartition = async () => {\n    const accessToken = await auth?.kas.getToken();\n    if (accessToken !== undefined && accessToken !== '') {\n      try {\n        const apisService = new DefaultApi(\n          new Configuration({\n            accessToken,\n            basePath,\n          })\n        );\n        if (!kafkaID) {\n          return;\n        }\n        const data = await apisService.getMetricsByRangeQuery(\n          kafkaID,\n          timeDuration * 60,\n          timeInterval * 60,\n          ['kafka_log_log_size']\n        );\n\n        const partitionArray: Partition[] = [];\n\n        if (data.data.items) {\n          setMetricsDataUnavailable(false);\n          data.data.items?.forEach((item, i) => {\n            const topicName = item?.metric?.topic;\n            const labels = item.metric;\n            if (item.metric === undefined) {\n              throw new Error('item.metric cannot be undefined');\n            }\n            if (item.values === undefined) {\n              throw new Error('item.values cannot be undefined');\n            }\n\n            const topic = {\n              name: topicName,\n              data: [],\n            } as Partition;\n\n            const isTopicInArray = partitionArray.some(\n              (topic) => topic.name === topicName\n            );\n\n            if (labels['__name__'] === 'kafka_topic:kafka_log_log_size:sum') {\n              item.values?.forEach((value) => {\n                if (value.timestamp == undefined) {\n                  throw new Error('timestamp cannot be undefined');\n                }\n\n                if (isTopicInArray) {\n                  partitionArray.forEach((topic: Partition) => {\n                    if (topic.name === topicName) {\n                      topic.data.forEach(\n                        (datum) => (datum.bytes = datum.bytes + value.value)\n                      );\n                    }\n                  });\n                } else {\n                  topic.data.push({\n                    name: topicName || '',\n                    timestamp: value.timestamp,\n                    bytes: value.value,\n                  });\n                }\n              });\n            }\n\n            if (!isTopicInArray) {\n              partitionArray.push(topic);\n            }\n          });\n          // Check if atleast one topic exists that isn't Strimzi Canary or Consumer Offsets - Keep this here for testing purposes\n          const filteredTopics = partitionArray.filter(\n            (topic) =>\n              topic.name !== '__strimzi_canary' &&\n              topic.name !== '__consumer_offsets'\n          );\n\n          if (filteredTopics.length < 1) {\n            setNoTopics(true);\n          }\n          getChartData(filteredTopics);\n        } else {\n          setMetricsDataUnavailable(true);\n          setChartDataLoading(false);\n        }\n      } catch (error) {\n        let reason: string | undefined;\n        if (isServiceApiError(error)) {\n          reason = error.response?.data.reason;\n        }\n        addAlert({\n          variant: AlertVariant.danger,\n          title: t('common.something_went_wrong'),\n          description: reason,\n        });\n      }\n    }\n  };\n\n  useEffect(() => {\n    fetchLogSizePerPartition();\n    handleResize();\n  }, [timeInterval, timeDuration]);\n\n  // useTimeout(() => fetchLogSizePerPartition(), 1000 * 60 * 5);\n\n  useEffect(() => {\n    handleResize();\n    window.addEventListener('resize', handleResize);\n  }, [width]);\n\n  const getChartData = (partitionArray) => {\n    const legendData: Array<LegendData> = [];\n    const chartData: Array<ChartData> = [];\n    const largestByteSize = getLargestByteSize(partitionArray, undefined);\n    partitionArray.map((partition, index) => {\n      const color = colors[index];\n      legendData.push({\n        name: partition.name,\n      });\n      const area: Array<PartitionChartData> = [];\n\n      const getCurrentLengthOfData = () => {\n        const timestampDiff =\n          partition.data[partition.data.length - 1].timestamp -\n          partition.data[0].timestamp;\n        const minutes = timestampDiff / 1000 / 60;\n        return minutes;\n      };\n      const lengthOfData = 6 * 60 - getCurrentLengthOfData();\n      const lengthOfDataPer5Mins = (6 * 60 - getCurrentLengthOfData()) / 5;\n\n      if (lengthOfData <= 360 && timeDuration >= 6) {\n        for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n          const newtimestamp =\n            partition.data[0].timestamp -\n            (lengthOfDataPer5Mins - i) * (5 * 60000);\n          const date = new Date(newtimestamp);\n          const time = dateToChartValue(date, {\n            showDate: shouldShowDate(timeDuration),\n          });\n          area.push({ name: partition.name, x: time, y: 0 });\n        }\n      }\n\n      partition.data.map((value) => {\n        const date = new Date(value.timestamp);\n        const time = dateToChartValue(date, {\n          showDate: shouldShowDate(timeDuration),\n        });\n        const bytes = convertToSpecifiedByte(value.bytes, largestByteSize);\n        area.push({ name: value.name, x: time, y: bytes });\n      });\n      chartData.push({ color, area });\n    });\n    setLegend(legendData);\n    setChartData(chartData);\n    setLargestByteSize(largestByteSize);\n    setChartDataLoading(false);\n  };\n\n  return (\n    <Card>\n      <CardTitle component='h2'>\n        {t('metrics.log_size_per_partition')}{' '}\n        <ChartPopover\n          title={t('metrics.log_size_per_partition')}\n          description={t('metrics.log_size_per_partition_help_text')}\n        />\n      </CardTitle>\n      <CardBody>\n        <div ref={containerRef}>\n          {!chartDataLoading ? (\n            !metricsDataUnavailable ? (\n              !noTopics ? (\n                chartData &&\n                legend &&\n                byteSize && (\n                  <Chart\n                    ariaTitle={t('metrics.log_size_per_partition')}\n                    containerComponent={\n                      <ChartVoronoiContainer\n                        labels={({ datum }) => `${datum.name}: ${datum.y}`}\n                        constrainToVisibleArea\n                      />\n                    }\n                    legendPosition='bottom-left'\n                    legendComponent={\n                      <ChartLegend data={legend} itemsPerRow={itemsPerRow} />\n                    }\n                    height={350}\n                    padding={{\n                      bottom: 110,\n                      left: 90,\n                      right: 30,\n                      top: 25,\n                    }}\n                    themeColor={ChartThemeColor.multiUnordered}\n                    width={width}\n                    legendAllowWrap={true}\n                  >\n                    <ChartAxis label={'\\n' + 'Time'} tickCount={6} />\n                    <ChartAxis\n                      dependentAxis\n                      tickFormat={(t) => `${Math.round(t)} ${largestByteSize}`}\n                    />\n                    <ChartGroup>\n                      {chartData.map((value, index) => (\n                        <ChartArea\n                          key={`chart-area-${index}`}\n                          data={value.area}\n                          interpolation='monotoneX'\n                        />\n                      ))}\n                    </ChartGroup>\n                  </Chart>\n                )\n              ) : (\n                <ChartEmptyState\n                  title={t('metrics.empty_state_no_topics_title')}\n                  body={t('metrics.empty_state_no_topics_body')}\n                  noTopics\n                />\n              )\n            ) : (\n              <ChartEmptyState\n                title={t('metrics.empty_state_no_data_title')}\n                body={t('metrics.empty_state_no_data_body')}\n                noData\n              />\n            )\n          ) : (\n            <Bullseye>\n              <Spinner isSVG />\n            </Bullseye>\n          )}\n        </div>\n      </CardBody>\n    </Card>\n  );\n};\n","import React, { useEffect, useState } from 'react';\nimport {\n  ToolbarItem,\n  Select,\n  SelectVariant,\n  SelectGroup,\n  SelectOption,\n} from '@patternfly/react-core';\nimport FilterIcon from '@patternfly/react-icons/dist/js/icons/filter-icon';\n\ntype FilterByTopicProps = {\n  setSelectedTopic?: (value: string | boolean) => void;\n  selectedTopic?: string | boolean;\n  topicList?: string[];\n  setIsFilterApplied?: (value: boolean) => void;\n  disableToolbar: boolean;\n};\n\nexport const FilterByTopic = ({\n  selectedTopic,\n  setSelectedTopic,\n  topicList,\n  setIsFilterApplied,\n  disableToolbar,\n}: FilterByTopicProps) => {\n  const [isTopicSelectOpen, setIsTopicSelectOpen] = useState<boolean>(false);\n  const [topicListFinal, setTopicListFinal] = useState<string[]>();\n\n  useEffect(() => {\n    topicList && setTopicListFinal(topicList);\n  }, [topicList]);\n\n  const onTopicToggle = (isTopicSelectOpen) => {\n    setIsTopicSelectOpen(isTopicSelectOpen);\n  };\n\n  const onTopicSelect = (_, selection) => {\n    setSelectedTopic && setSelectedTopic(selection);\n    setIsFilterApplied &&\n      (selection !== 'All topics'\n        ? setIsFilterApplied(true)\n        : setIsFilterApplied(false));\n    setIsTopicSelectOpen(false);\n  };\n\n  const onTopicFilter = (_, textInput) => {\n    const filteredTopics =\n      topicListFinal?.filter((topic) => topic.indexOf(textInput) != -1) || [];\n    return topicOptions(filteredTopics);\n  };\n\n  const topicOptions = (topicList) => [\n    <SelectOption key={'topic-filter-0'} value='All topics' />,\n    <SelectGroup label='Filter by topic' key='topic-filter-group'>\n      {topicList?.map((topic, index) => (\n        <SelectOption key={`topic-filter-${index + 1}`} value={topic} />\n      ))}\n    </SelectGroup>,\n  ];\n\n  const widths = {\n    default: '100px',\n    sm: '80px',\n    md: '150px',\n    lg: '200px',\n    xl: '250px',\n    '2xl': '300px',\n  };\n\n  return (\n    <ToolbarItem widths={widths}>\n      <Select\n        variant={SelectVariant.single}\n        onToggle={onTopicToggle}\n        onSelect={onTopicSelect}\n        selections={selectedTopic}\n        isOpen={isTopicSelectOpen}\n        placeholderText={\n          <>\n            <FilterIcon /> All topics\n          </>\n        }\n        aria-labelledby={'titleId'}\n        onFilter={onTopicFilter}\n        isGrouped\n        hasInlineFilter\n        isDisabled={disableToolbar}\n        style={{ width: '100%' }}\n      >\n        {topicOptions(topicListFinal)}\n      </Select>\n    </ToolbarItem>\n  );\n};\n","import React, { useState } from 'react';\nimport {\n  ToolbarItem,\n  Select,\n  SelectVariant,\n  SelectGroup,\n  SelectOption,\n} from '@patternfly/react-core';\nimport { formatTime } from '../../utils';\n\ntype FilterByTimeProps = {\n  setTimeDuration: (value: number) => void;\n  setTimeInterval: (value: number) => void;\n  keyText: string;\n  disableToolbar: boolean;\n};\n\nexport const FilterByTime = ({\n  setTimeDuration,\n  setTimeInterval,\n  keyText,\n  disableToolbar,\n}: FilterByTimeProps) => {\n  const [selectedTime, setSelectedTime] = useState<boolean>(false);\n  const [isTimeSelectOpen, setIsTimeSelectOpen] = useState<boolean>(false);\n\n  const onTimeToggle = (isTimeSelectOpen) => {\n    setIsTimeSelectOpen(isTimeSelectOpen);\n  };\n\n  const onTimeSelect = (_, selection) => {\n    setTimeDuration(formatTime(selection).timeDuration);\n    setTimeInterval(formatTime(selection).timeInterval);\n    setSelectedTime(selection);\n    setIsTimeSelectOpen(false);\n  };\n\n  const timeOptions = (keyText: string) => [\n    <SelectGroup label='Relative time ranges' key={`${keyText}-group`}>\n      <SelectOption key={`${keyText}-0`} value='Last 5 minutes' />\n      <SelectOption key={`${keyText}-1`} value='Last 15 minutes' />\n      <SelectOption key={`${keyText}-2`} value='Last 30 minutes' />\n      <SelectOption key={`${keyText}-3`} value='Last 1 hour' />\n      <SelectOption key={`${keyText}-4`} value='Last 3 hours' />\n      <SelectOption key={`${keyText}-5`} value='Last 6 hours' />\n      <SelectOption key={`${keyText}-6`} value='Last 12 hours' />\n      <SelectOption key={`${keyText}-7`} value='Last 24 hours' />\n      <SelectOption key={`${keyText}-8`} value='Last 2 days' />\n      <SelectOption key={`${keyText}-9`} value='Last 7 days' />\n    </SelectGroup>,\n  ];\n  return (\n    <ToolbarItem>\n      <Select\n        variant={SelectVariant.single}\n        aria-label='Select Input'\n        onToggle={onTimeToggle}\n        onSelect={onTimeSelect}\n        selections={selectedTime}\n        isOpen={isTimeSelectOpen}\n        isDisabled={disableToolbar}\n        placeholderText='Last 6 hours'\n      >\n        {timeOptions(keyText)}\n      </Select>\n    </ToolbarItem>\n  );\n};\n","import React from 'react';\nimport {\n  Button,\n  CardTitle,\n  Divider,\n  Level,\n  LevelItem,\n  Toolbar,\n  ToolbarContent,\n} from '@patternfly/react-core';\nimport SyncIcon from '@patternfly/react-icons/dist/js/icons/sync-icon';\nimport { FilterByTopic } from './FilterByTopic';\nimport { FilterByTime } from './FilterByTime';\n\ntype ChartToolbarProps = {\n  title: string;\n  showTopicFilter: boolean;\n  setTimeDuration: (value: number) => void;\n  showTopicToolbar?: boolean;\n  showKafkaToolbar?: boolean;\n  setTimeInterval: (value: number) => void;\n  setSelectedTopic?: (value: string | boolean) => void;\n  selectedTopic?: string | boolean;\n  onRefreshKafkaToolbar?: () => void;\n  onRefreshTopicToolbar?: () => void;\n  topicList?: string[];\n  setIsFilterApplied?: (value: boolean) => void;\n};\nexport const ChartToolbar = ({\n  title,\n  showTopicFilter,\n  setTimeDuration,\n  setTimeInterval,\n  showKafkaToolbar = true,\n  showTopicToolbar = true,\n  setSelectedTopic,\n  selectedTopic,\n  onRefreshKafkaToolbar,\n  onRefreshTopicToolbar,\n  topicList,\n  setIsFilterApplied,\n}: ChartToolbarProps) => {\n  return (\n    <>\n      <Level>\n        <LevelItem>\n          <CardTitle component='h2'>{title}</CardTitle>\n        </LevelItem>\n        <LevelItem>\n          {showTopicFilter ? (\n            <Toolbar>\n              <ToolbarContent>\n                <FilterByTopic\n                  selectedTopic={selectedTopic}\n                  setSelectedTopic={setSelectedTopic}\n                  topicList={topicList}\n                  setIsFilterApplied={setIsFilterApplied}\n                  disableToolbar={!showTopicToolbar}\n                />\n                <FilterByTime\n                  setTimeDuration={setTimeDuration}\n                  setTimeInterval={setTimeInterval}\n                  disableToolbar={!showTopicToolbar}\n                  keyText={'topic-metrics-time-filter'}\n                />\n                <Button\n                  variant='plain'\n                  aria-label='sync'\n                  onClick={onRefreshTopicToolbar}\n                >\n                  <SyncIcon />\n                </Button>\n              </ToolbarContent>\n            </Toolbar>\n          ) : (\n            <Toolbar>\n              <ToolbarContent>\n                <FilterByTime\n                  setTimeDuration={setTimeDuration}\n                  setTimeInterval={setTimeInterval}\n                  keyText={'kafka-metrics-time-filter'}\n                  disableToolbar={!showKafkaToolbar}\n                />\n                <Button\n                  variant='plain'\n                  aria-label='sync'\n                  onClick={onRefreshKafkaToolbar}\n                >\n                  <SyncIcon />\n                </Button>\n              </ToolbarContent>\n            </Toolbar>\n          )}\n        </LevelItem>\n      </Level>\n      <Divider />\n    </>\n  );\n};\n"],"names":["ChartEmptyState","title","body","noData","noTopics","noFilter","onCreateTopic","EmptyState","variant","EmptyStateVariant","EmptyStateIcon","icon","Title","headingLevel","size","EmptyStateBody","Button","onClick","getLargestByteSize","data1","data2","currentByteSize","sortedData","data","map","datum","bytes","forEach","value","byteString","unit","convertToSpecifiedByte","largestByteSize","Math","round","shouldShowDate","timeDuration","dateToChartValue","date","showDate","toISOString","split","dateValue","timeValue","slice","formatTime","selection","timeInterval","ChartPopover","description","Popover","headerContent","bodyContent","UsedDiskSpaceChart","kafkaID","metricsDataUnavailable","setMetricsDataUnavailable","containerRef","useRef","t","useTranslation","auth","useAuth","basePath","useConfig","addAlert","useAlert","useState","width","setWidth","legend","setLegend","chartData","setChartData","chartDataLoading","setChartDataLoading","setLargestByteSize","setTimeDuration","setTimeInterval","handleResize","current","clientWidth","itemsPerRow","fetchUsedDiskSpaceMetrics","kas","getToken","undefined","accessToken","apisService","DefaultApi","Configuration","getMetricsByRangeQuery","name","items","item","index","labels","metric","Error","values","includes","indexJ","timestamp","newArray","usedSpaceAvg","concat","push","getChartData","reason","response","AlertVariant","useEffect","window","addEventListener","avgBroker","legendData","symbol","fill","chart_color_black_500","type","chart_color_blue_300","areaColor","softLimitColor","area","softLimit","getCurrentLengthOfData","length","lengthOfData","lengthOfDataPer5Mins","i","newTimestamp","Date","time","x","y","aggregateBytes","reduce","a","b","Card","ChartToolbar","showTopicFilter","showKafkaToolbar","onRefreshKafkaToolbar","CardTitle","component","CardBody","ref","Bullseye","Spinner","isSVG","Chart","ariaTitle","containerComponent","ChartVoronoiContainer","constrainToVisibleArea","legendPosition","legendComponent","ChartLegend","orientation","height","padding","bottom","left","right","top","themeColor","ChartThemeColor","minDomain","legendAllowWrap","ChartAxis","label","tickCount","dependentAxis","tickFormat","ChartGroup","ChartArea","key","interpolation","style","ChartThreshold","stroke","IncomingOutgoingBytesPerTopic","selectedTopic","setSelectedTopic","isFilterApplied","setIsFilterApplied","setNoTopics","topicList","setTopicList","fetchBytesData","rawData","Map","indexOf","has","get","set","sort","incomingTopicArray","outgoingTopicArray","color","line","chart_color_orange_300","showTopicToolbar","onRefreshTopicToolbar","ChartLine","Divider","LogSizePerPartitionChart","colors","chart_color_green_300","topicName","topic","isTopicInArray","some","filteredTopics","filter","partitionArray","partition","newtimestamp","FilterByTopic","disableToolbar","isTopicSelectOpen","setIsTopicSelectOpen","topicListFinal","setTopicListFinal","topicOptions","SelectOption","SelectGroup","ToolbarItem","widths","default","sm","md","lg","xl","Select","SelectVariant","onToggle","onSelect","_","selections","isOpen","placeholderText","onFilter","textInput","isGrouped","hasInlineFilter","isDisabled","FilterByTime","keyText","selectedTime","setSelectedTime","isTimeSelectOpen","setIsTimeSelectOpen","timeOptions","Level","LevelItem","Toolbar","ToolbarContent"],"sourceRoot":""}