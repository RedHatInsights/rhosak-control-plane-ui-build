{"version":3,"file":"3832.e78b57c0.js","mappings":"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","sources":["webpack://kas-ui/./src/app/modules/Metrics/components/ChartPopover.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/EmptyStateInitialLoading.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/EmptyStateMetricsUnavailable.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/EmptyStateNoTopicData.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/EmptyStateNoTopics.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/EmptyStateNoTopicSelected.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/FilterByTime.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/FilterByTopic.tsx","webpack://kas-ui/./src/app/modules/Metrics/utils/utils.ts","webpack://kas-ui/./src/app/modules/Metrics/components/ChartLogSizePerPartition.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/MetricsLayout.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ToolbarTopicsMetrics.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ChartLoading.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/CardTopicsMetrics.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ChartTotalBytes.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ChartUsedDiskSpace.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/ToolbarUsedDiskSpace.tsx","webpack://kas-ui/./src/app/modules/Metrics/components/CardUsedDiskSpace.tsx","webpack://kas-ui/./src/app/modules/Metrics/machines/DiskSpaceMetricsMachine.ts","webpack://kas-ui/./src/app/modules/Metrics/machines/TopicsMetricsMachine.ts","webpack://kas-ui/./src/app/modules/Metrics/MetricsProvider.tsx","webpack://kas-ui/./src/app/modules/Metrics/useDiskSpace.tsx","webpack://kas-ui/./src/app/modules/Metrics/Metrics.tsx","webpack://kas-ui/./src/app/modules/Metrics/useTopicsMetrics.tsx"],"sourcesContent":["import { Popover } from '@patternfly/react-core';\nimport OutlinedQuestionCircleIcon from '@patternfly/react-icons/dist/js/icons/outlined-question-circle-icon';\nimport React from 'react';\n\ntype ChartPopoverProps = {\n  title: string;\n  description: string;\n};\n\nexport const ChartPopover = ({ title, description }: ChartPopoverProps) => {\n  return (\n    <Popover\n      aria-label='Basic popover'\n      headerContent={<div>{title}</div>}\n      bodyContent={<div>{description}</div>}\n    >\n      <OutlinedQuestionCircleIcon />\n    </Popover>\n  );\n};\n","import { MASLoading } from '@app/common';\nimport {\n  EmptyState,\n  EmptyStateBody,\n  EmptyStateVariant,\n} from '@patternfly/react-core';\nimport React from 'react';\n\nexport const EmptyStateInitialLoading = () => {\n  return (\n    <EmptyState variant={EmptyStateVariant.xs}>\n      <EmptyStateBody>\n        <MASLoading />\n      </EmptyStateBody>\n    </EmptyState>\n  );\n};\n","import {\n  EmptyState,\n  EmptyStateVariant,\n  EmptyStateIcon,\n  Title,\n  EmptyStateBody,\n} from '@patternfly/react-core';\nimport { TachometerAltIcon } from '@patternfly/react-icons';\nimport React, { FunctionComponent } from 'react';\nimport { useTranslation } from 'react-i18next';\n\nexport const EmptyStateMetricsUnavailable: FunctionComponent = () => {\n  const { t } = useTranslation();\n  return (\n    <EmptyState variant={EmptyStateVariant.xs}>\n      <EmptyStateIcon icon={TachometerAltIcon} />\n      <Title headingLevel='h3' size='lg'>\n        {t('metrics.empty_state_no_data_title')}\n      </Title>\n      <EmptyStateBody>{t('metrics.empty_state_no_data_body')}</EmptyStateBody>\n    </EmptyState>\n  );\n};\n","import {\n  EmptyState,\n  EmptyStateBody,\n  EmptyStateIcon,\n  EmptyStateVariant,\n  Title,\n} from '@patternfly/react-core';\nimport { SearchIcon } from '@patternfly/react-icons';\nimport React, { FunctionComponent } from 'react';\nimport { useTranslation } from 'react-i18next';\n\nexport const EmptyStateNoTopicData: FunctionComponent = () => {\n  const { t } = useTranslation();\n  return (\n    <EmptyState variant={EmptyStateVariant.xs}>\n      <EmptyStateIcon icon={SearchIcon} />\n      <Title headingLevel='h3' size='lg'>\n        {t('metrics.empty_state_no_topic_data_title')}\n      </Title>\n      <EmptyStateBody>\n        {t('metrics.empty_state_no_topic_data_body')}\n      </EmptyStateBody>\n    </EmptyState>\n  );\n};\n","import {\n  Button,\n  EmptyState,\n  EmptyStateBody,\n  EmptyStateIcon,\n  EmptyStateVariant,\n  Title,\n} from '@patternfly/react-core';\nimport { WrenchIcon } from '@patternfly/react-icons';\nimport React, { FunctionComponent } from 'react';\nimport { useTranslation } from 'react-i18next';\n\ntype EmptyStateNoTopicsProps = {\n  onCreateTopic: () => void;\n};\nexport const EmptyStateNoTopics: FunctionComponent<EmptyStateNoTopicsProps> = ({\n  onCreateTopic,\n}) => {\n  const { t } = useTranslation();\n  return (\n    <EmptyState variant={EmptyStateVariant.xs}>\n      <EmptyStateIcon icon={WrenchIcon} />\n      <Title headingLevel='h3' size='lg'>\n        {t('metrics.empty_state_no_topics_title')}\n      </Title>\n      <EmptyStateBody>{t('metrics.empty_state_no_topics_body')}</EmptyStateBody>\n      <Button variant='primary' onClick={onCreateTopic}>\n        {t('metrics.empty_state_no_topics_create_topic')}\n      </Button>\n    </EmptyState>\n  );\n};\n","import {\n  EmptyState,\n  EmptyStateVariant,\n  EmptyStateIcon,\n  Title,\n  EmptyStateBody,\n} from '@patternfly/react-core';\nimport { FilterIcon } from '@patternfly/react-icons';\nimport React from 'react';\nimport { useTranslation } from 'react-i18next';\n\nexport const EmptyStateNoTopicSelected = () => {\n  const { t } = useTranslation();\n  return (\n    <EmptyState variant={EmptyStateVariant.xs}>\n      <EmptyStateIcon icon={FilterIcon} />\n      <Title headingLevel='h3' size='lg'>\n        {t('metrics.empty_state_no_filter_title')}\n      </Title>\n      <EmptyStateBody>{t('metrics.empty_state_no_filter_body')}</EmptyStateBody>\n    </EmptyState>\n  );\n};\n","import React, { useState } from 'react';\nimport {\n  ToolbarItem,\n  Select,\n  SelectVariant,\n  SelectGroup,\n  SelectOption,\n  SelectProps,\n} from '@patternfly/react-core';\n\nconst DurationOptionsMap = {\n  5: 'Last 5 minutes',\n  15: 'Last 15 minutes',\n  30: 'Last 30 minutes',\n  60: 'Last 1 hour',\n  180: 'Last 3 hours',\n  360: 'Last 6 hours',\n  720: 'Last 12 hours',\n  1400: 'Last 24 hours',\n  2800: 'Last 2 days',\n  100080: 'Last 7 days',\n};\n\nexport type DurationOptions = keyof typeof DurationOptionsMap;\n\ntype FilterByTimeProps = {\n  timeDuration: DurationOptions;\n  onDurationChange: (value: DurationOptions) => void;\n  keyText: string;\n  disableToolbar: boolean;\n};\n\nexport const FilterByTime = ({\n  timeDuration,\n  keyText,\n  disableToolbar,\n  onDurationChange,\n}: FilterByTimeProps) => {\n  const [isTimeSelectOpen, setIsTimeSelectOpen] = useState<boolean>(false);\n\n  const onTimeToggle = (isTimeSelectOpen) => {\n    setIsTimeSelectOpen(isTimeSelectOpen);\n  };\n\n  const onTimeSelect: SelectProps['onSelect'] = (_, selection) => {\n    const mapping = Object.entries(DurationOptionsMap).find(\n      ([_, value]) => value === selection\n    );\n    if (mapping) {\n      onDurationChange(parseInt(mapping[0], 10) as DurationOptions);\n    }\n    setIsTimeSelectOpen(false);\n  };\n\n  const timeOptions = (keyText: string) => [\n    <SelectGroup label='Relative time ranges' key={`${keyText}-group`}>\n      {Object.values(DurationOptionsMap).map((label, idx) => (\n        <SelectOption key={`${keyText}-${idx}`} value={label} />\n      ))}\n    </SelectGroup>,\n  ];\n  return (\n    <ToolbarItem>\n      <Select\n        variant={SelectVariant.single}\n        aria-label='Select Input'\n        onToggle={onTimeToggle}\n        onSelect={onTimeSelect}\n        selections={DurationOptionsMap[timeDuration]}\n        isOpen={isTimeSelectOpen}\n        isDisabled={disableToolbar}\n        placeholderText='Last 6 hours'\n      >\n        {timeOptions(keyText)}\n      </Select>\n    </ToolbarItem>\n  );\n};\n","import React, { useState } from 'react';\nimport {\n  ToolbarItem,\n  Select,\n  SelectVariant,\n  SelectGroup,\n  SelectOption,\n} from '@patternfly/react-core';\nimport FilterIcon from '@patternfly/react-icons/dist/js/icons/filter-icon';\nimport { useTranslation } from 'react-i18next';\n\nconst widths = {\n  default: '100px',\n  sm: '80px',\n  md: '150px',\n  lg: '200px',\n  xl: '250px',\n  '2xl': '300px',\n};\n\ntype FilterByTopicProps = {\n  selectedTopic: string | undefined;\n  topicList: string[];\n  disableToolbar: boolean;\n  onSetSelectedTopic: (value: string | undefined) => void;\n};\n\nexport const FilterByTopic = ({\n  selectedTopic,\n  topicList = [],\n  disableToolbar,\n  onSetSelectedTopic,\n}: FilterByTopicProps) => {\n  const { t } = useTranslation();\n  const [isTopicSelectOpen, setIsTopicSelectOpen] = useState<boolean>(false);\n\n  const allTopicsLabel = t('All topics');\n\n  const onTopicToggle = (isTopicSelectOpen) => {\n    setIsTopicSelectOpen(isTopicSelectOpen);\n  };\n\n  const onTopicSelect = (_, selection) => {\n    selection !== 'All topics'\n      ? onSetSelectedTopic(selection)\n      : onSetSelectedTopic(undefined);\n  };\n\n  const onTopicFilter = (_, textInput) => {\n    const filteredTopics =\n      topicList.filter((topic) => topic.indexOf(textInput) != -1) || [];\n    return topicOptions(filteredTopics);\n  };\n\n  const topicOptions = (topicList) => [\n    <SelectOption key={'topic-filter-0'} value={allTopicsLabel} />,\n    <SelectGroup label='Filter by topic' key='topic-filter-group'>\n      {topicList.map((topic, index) => (\n        <SelectOption key={`topic-filter-${index + 1}`} value={topic} />\n      ))}\n    </SelectGroup>,\n  ];\n\n  const isDisabled = disableToolbar || topicList.length === 0;\n\n  return (\n    <ToolbarItem widths={widths}>\n      <Select\n        variant={SelectVariant.single}\n        onToggle={onTopicToggle}\n        onSelect={onTopicSelect}\n        selections={selectedTopic || allTopicsLabel}\n        isOpen={isTopicSelectOpen}\n        placeholderText={\n          <>\n            <FilterIcon /> All topics\n          </>\n        }\n        aria-label={t('Select a topic')}\n        onFilter={onTopicFilter}\n        isGrouped\n        hasInlineFilter\n        isDisabled={isDisabled}\n        style={{ width: '100%' }}\n      >\n        {topicOptions(topicList)}\n      </Select>\n    </ToolbarItem>\n  );\n};\n","import byteSize from 'byte-size';\n\nexport type SupportedSizes = 'B' | 'kiB' | 'MiB' | 'GiB';\n\nexport const getLargestByteSize = (data1, data2): SupportedSizes => {\n  let currentByteSize: SupportedSizes = 'B';\n\n  data1 = data1 && (data1.sortedData ? data1.sortedData : data1.data);\n  data2 = data2 && (data2.sortedData ? data2.sortedData : data2.data);\n\n  data1 &&\n    data1.map((datum) => {\n      datum.bytes.forEach((value) => {\n        const byteString = byteSize(value).unit;\n        if (byteString === 'kiB') {\n          if (currentByteSize === 'B') {\n            currentByteSize = 'kiB';\n          }\n        }\n        if (byteString === 'MiB') {\n          if (currentByteSize === 'B' || currentByteSize === 'kiB') {\n            currentByteSize = 'MiB';\n          }\n        }\n        if (byteString === 'GiB') {\n          if (\n            currentByteSize === 'B' ||\n            currentByteSize === 'kiB' ||\n            currentByteSize === 'MiB'\n          ) {\n            currentByteSize = 'GiB';\n          }\n        }\n      });\n    });\n\n  data2 &&\n    data2.map((datum) => {\n      datum.bytes.forEach((value) => {\n        const byteString = byteSize(value).unit;\n        if (byteString === 'kiB') {\n          if (currentByteSize === 'B') {\n            currentByteSize = 'kiB';\n          }\n        }\n        if (byteString === 'MiB') {\n          if (currentByteSize === 'B' || currentByteSize === 'kiB') {\n            currentByteSize = 'MiB';\n          }\n        }\n        if (byteString === 'GiB') {\n          if (\n            currentByteSize === 'B' ||\n            currentByteSize === 'kiB' ||\n            currentByteSize === 'MiB'\n          ) {\n            currentByteSize = 'GiB';\n          }\n        }\n      });\n    });\n\n  return currentByteSize;\n};\n\nexport const convertToSpecifiedByte = (\n  bytes: number,\n  largestByteSize: SupportedSizes\n): number => {\n  if (largestByteSize === 'B') {\n    return Math.round(bytes * 10) / 10;\n  }\n  if (largestByteSize === 'kiB') {\n    return Math.round((bytes / 1024) * 10) / 10;\n  }\n  if (largestByteSize === 'MiB') {\n    return Math.round((bytes / 1024 / 1024) * 10) / 10;\n  }\n  if (largestByteSize === 'GiB') {\n    return Math.round((bytes / 1024 / 1024 / 1024) * 10) / 10;\n  }\n  return bytes;\n};\n\nexport const shouldShowDate = (timeDuration) => {\n  return timeDuration >= 24 ? true : false;\n};\n\nexport const dateToChartValue = (date, { showDate }) => {\n  const [dateValue, timeValue] = date.toISOString().split('T');\n  return showDate\n    ? timeValue.slice(0, 5) + '\\n' + dateValue\n    : timeValue.slice(0, 5);\n};\nexport const getMaxValueOfArray = (data) => {\n  const max = data.reduce(function (prev, current) {\n    return prev.bytes > current.bytes ? prev : current;\n  });\n  return max.bytes;\n};\n\n//Add a scalable logic to set duration and interval\nexport const formatTime = (selection: string) => {\n  let timeDuration = 6;\n  let timeInterval = 1 * 60; //in minutes\n  switch (selection) {\n    case 'Last 5 minutes':\n      timeDuration = 5 / 60;\n      timeInterval = 1;\n      break;\n    case 'Last 15 minutes':\n      timeDuration = 15 / 60;\n      timeInterval = 3;\n      break;\n    case 'Last 30 minutes':\n      timeDuration = 30 / 60;\n      timeInterval = 5;\n      break;\n    case 'Last 1 hour':\n      timeDuration = 1;\n      timeInterval = 10;\n      break;\n    case 'Last 3 hours':\n      timeDuration = 3;\n      timeInterval = 30;\n      break;\n    case 'Last 6 hours':\n      timeDuration = 6;\n      timeInterval = 1 * 60;\n      break;\n    case 'Last 12 hours':\n      timeDuration = 12;\n      timeInterval = 2 * 60;\n      break;\n    case 'Last 24 hours':\n      timeDuration = 24;\n      timeInterval = 4 * 60;\n      break;\n    case 'Last 2 days':\n      timeDuration = 2 * 24;\n      timeInterval = 8 * 60;\n      break;\n    case 'Last 7 days':\n      timeDuration = 7 * 24;\n      timeInterval = 24 * 60;\n      break;\n  }\n  return { timeDuration, timeInterval };\n};\n\nexport const timeIntervalsMapping = {\n  5: 1 * 60,\n  15: 3 * 60,\n  30: 5 * 60,\n  60: 10 * 60,\n  180: 30 * 60,\n  360: 1 * 60 * 60,\n  720: 2 * 60 * 60,\n  1400: 4 * 60 * 60,\n  2800: 8 * 60 * 60,\n  100080: 24 * 60 * 60,\n};\n","import { PartitionBytesMetric } from '@app/modules/Metrics/MetricsApi';\nimport {\n  convertToSpecifiedByte,\n  dateToChartValue,\n  getLargestByteSize,\n  shouldShowDate,\n} from '@app/modules/Metrics/utils';\nimport {\n  Chart,\n  ChartArea,\n  ChartAxis,\n  ChartGroup,\n  ChartLegend,\n  ChartThemeColor,\n  ChartVoronoiContainer,\n} from '@patternfly/react-charts';\nimport chart_color_blue_300 from '@patternfly/react-tokens/dist/js/chart_color_blue_300';\nimport chart_color_green_300 from '@patternfly/react-tokens/dist/js/chart_color_green_300';\nimport React, { FunctionComponent, useEffect, useRef, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\n\nconst colors = [chart_color_green_300.value, chart_color_blue_300.value];\n\ntype ChartData = {\n  color: string;\n  area: PartitionChartData[];\n};\n\ntype PartitionChartData = {\n  name: string;\n  x: string;\n  y: number;\n};\n\ntype LegendData = {\n  name: string;\n};\n\nexport type ChartLogSizePerPartitionProps = {\n  partitions: PartitionBytesMetric;\n  timeDuration: number;\n};\nexport const ChartLogSizePerPartition: FunctionComponent<ChartLogSizePerPartitionProps> =\n  ({ partitions, timeDuration }) => {\n    const { t } = useTranslation();\n\n    const containerRef = useRef<HTMLDivElement | null>(null);\n    const [width, setWidth] = useState<number>();\n\n    const handleResize = () =>\n      containerRef.current && setWidth(containerRef.current.clientWidth);\n    const itemsPerRow = width && width > 650 ? 6 : 3;\n\n    useEffect(() => {\n      handleResize();\n      window.addEventListener('resize', handleResize);\n    }, [width]);\n\n    const { chartData, largestByteSize, legendData } =\n      getLogSizePerPartitionChartData(partitions, timeDuration);\n\n    return (\n      <div ref={containerRef}>\n        <Chart\n          ariaTitle={t('metrics.log_size_per_partition')}\n          containerComponent={\n            <ChartVoronoiContainer\n              labels={({ datum }) => `${datum.name}: ${datum.y}`}\n              constrainToVisibleArea\n            />\n          }\n          legendPosition='bottom-left'\n          legendComponent={\n            <ChartLegend data={legendData} itemsPerRow={itemsPerRow} />\n          }\n          height={350}\n          padding={{\n            bottom: 110,\n            left: 90,\n            right: 30,\n            top: 25,\n          }}\n          themeColor={ChartThemeColor.multiUnordered}\n          width={width}\n          legendAllowWrap={true}\n        >\n          <ChartAxis label={'\\n' + 'Time'} tickCount={6} />\n          <ChartAxis\n            dependentAxis\n            tickFormat={(t) => `${Math.round(t)} ${largestByteSize}`}\n          />\n          <ChartGroup>\n            {chartData.map((value, index) => (\n              <ChartArea\n                key={`chart-area-${index}`}\n                data={value.area}\n                interpolation='monotoneX'\n              />\n            ))}\n          </ChartGroup>\n        </Chart>\n      </div>\n    );\n  };\n\nexport function getLogSizePerPartitionChartData(\n  partitions: PartitionBytesMetric,\n  timeDuration: number\n) {\n  const legendData: Array<LegendData> = [];\n  const chartData: Array<ChartData> = [];\n  const largestByteSize = getLargestByteSize(partitions, undefined);\n  Object.entries(partitions).map(([name, dataMap], index) => {\n    const timestamps = Object.keys(dataMap).map((s) => parseInt(s, 10));\n    const color = colors[index];\n    legendData.push({\n      name,\n    });\n    const area: Array<PartitionChartData> = [];\n\n    const getCurrentLengthOfData = () => {\n      const timestampDiff = timestamps[timestamps.length - 1] - timestamps[0];\n      const minutes = timestampDiff / 1000 / 60;\n      return minutes;\n    };\n    const lengthOfData = 6 * 60 - getCurrentLengthOfData();\n    const lengthOfDataPer5Mins = (6 * 60 - getCurrentLengthOfData()) / 5;\n\n    if (lengthOfData <= 360 && timeDuration >= 6) {\n      for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n        const newtimestamp =\n          timestamps[0] - (lengthOfDataPer5Mins - i) * (5 * 60000);\n        const date = new Date(newtimestamp);\n        const time = dateToChartValue(date, {\n          showDate: shouldShowDate(timeDuration),\n        });\n        area.push({ name, x: time, y: 0 });\n      }\n    }\n\n    Object.entries(dataMap).map(([timestamp, value]) => {\n      const date = new Date(parseInt(timestamp, 10));\n      const time = dateToChartValue(date, {\n        showDate: shouldShowDate(timeDuration),\n      });\n      const bytes = convertToSpecifiedByte(value, largestByteSize);\n      area.push({ name, x: time, y: bytes });\n    });\n    chartData.push({ color, area });\n  });\n  return {\n    legendData,\n    chartData,\n    largestByteSize,\n  };\n}\n","import { Grid, GridItem, PageSection } from '@patternfly/react-core';\nimport React, { ReactNode, FunctionComponent } from 'react';\n\ntype MetricsLayoutProps = {\n  diskSpaceMetrics: ReactNode;\n  topicMetrics: ReactNode;\n};\nexport const MetricsLayout: FunctionComponent<MetricsLayoutProps> = ({\n  diskSpaceMetrics,\n  topicMetrics,\n}) => {\n  return (\n    <PageSection>\n      <Grid hasGutter>\n        <GridItem lg={6}>{diskSpaceMetrics}</GridItem>\n        <GridItem lg={6}>{topicMetrics}</GridItem>\n      </Grid>\n    </PageSection>\n  );\n};\n","import {\n  Button,\n  CardActions,\n  CardHeader,\n  CardTitle,\n  Divider,\n  Toolbar,\n  ToolbarContent,\n  ToolbarItem,\n} from '@patternfly/react-core';\nimport SyncIcon from '@patternfly/react-icons/dist/js/icons/sync-icon';\nimport React, { FunctionComponent } from 'react';\nimport { DurationOptions, FilterByTime } from './FilterByTime';\nimport { FilterByTopic } from './FilterByTopic';\n\ntype ToolbarTopicsMetricsProps = {\n  title: string;\n  selectedTopic: string | undefined;\n  topicList: string[];\n  timeDuration: DurationOptions;\n  isDisabled: boolean;\n  isRefreshing: boolean;\n  onSetTimeDuration: (value: DurationOptions) => void;\n  onSetSelectedTopic: (value: string | undefined) => void;\n  onRefresh: () => void;\n};\nexport const ToolbarTopicsMetrics: FunctionComponent<ToolbarTopicsMetricsProps> =\n  ({\n    title,\n    selectedTopic,\n    topicList,\n    timeDuration,\n    isDisabled,\n    isRefreshing,\n    onSetTimeDuration,\n    onRefresh,\n    onSetSelectedTopic,\n  }) => {\n    return (\n      <>\n        <CardHeader>\n          <CardTitle component='h2'>{title}</CardTitle>\n          <CardActions>\n            <Toolbar>\n              <ToolbarContent>\n                <FilterByTopic\n                  selectedTopic={selectedTopic}\n                  onSetSelectedTopic={onSetSelectedTopic}\n                  topicList={topicList}\n                  disableToolbar={isDisabled}\n                />\n                <FilterByTime\n                  timeDuration={timeDuration}\n                  onDurationChange={onSetTimeDuration}\n                  disableToolbar={isDisabled}\n                  keyText={'topic-metrics-time-filter'}\n                />\n                <ToolbarItem>\n                  <Button\n                    isLoading={isRefreshing}\n                    variant='plain'\n                    aria-label='sync'\n                    onClick={onRefresh}\n                  >\n                    {!isRefreshing && <SyncIcon />}\n                  </Button>\n                </ToolbarItem>\n              </ToolbarContent>\n            </Toolbar>\n          </CardActions>\n        </CardHeader>\n        <Divider />\n      </>\n    );\n  };\n","import { CardBody, Bullseye, Spinner } from '@patternfly/react-core';\nimport React, { FunctionComponent } from 'react';\n\nexport const ChartLoading: FunctionComponent = () => (\n  <CardBody>\n    <Bullseye>\n      <Spinner isSVG />\n    </Bullseye>\n  </CardBody>\n);\n","import {\n  ChartLogSizePerPartition,\n  ChartPopover,\n  ChartTotalBytes,\n  EmptyStateNoTopicData,\n  EmptyStateNoTopicSelected,\n  ToolbarTopicsMetrics,\n} from '@app/modules/Metrics/components';\nimport {\n  PartitionBytesMetric,\n  TotalBytesMetrics,\n} from '@app/modules/Metrics/MetricsApi';\nimport {\n  Bullseye,\n  Card,\n  CardBody,\n  CardTitle,\n  Divider,\n  Spinner,\n} from '@patternfly/react-core';\nimport React, { FunctionComponent } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { ChartLoading } from './ChartLoading';\nimport { EmptyStateMetricsUnavailable } from './EmptyStateMetricsUnavailable';\nimport { EmptyStateNoTopics } from './EmptyStateNoTopics';\nimport { DurationOptions } from './FilterByTime';\n\ntype CardTopicsMetricsProps = {\n  topics: string[];\n  incomingTopicsData: TotalBytesMetrics;\n  outgoingTopicsData: TotalBytesMetrics;\n  partitions: PartitionBytesMetric;\n  timeDuration: DurationOptions;\n  backendUnavailable: boolean;\n  metricsDataUnavailable: boolean;\n  isLoading: boolean;\n  isRefreshing: boolean;\n  selectedTopic: string | undefined;\n  onCreateTopic: () => void;\n  onRefresh: () => void;\n  onSelectedTopic: (topic: string | undefined) => void;\n  onTimeDuration: (duration: DurationOptions) => void;\n};\n\nexport const CardTopicsMetrics: FunctionComponent<CardTopicsMetricsProps> = ({\n  topics,\n  incomingTopicsData,\n  outgoingTopicsData,\n  selectedTopic,\n  timeDuration,\n  partitions,\n  backendUnavailable,\n  metricsDataUnavailable,\n  isLoading,\n  isRefreshing,\n  onCreateTopic,\n  onRefresh,\n  onSelectedTopic,\n  onTimeDuration,\n}) => {\n  const { t } = useTranslation();\n  const noTopics = topics.length === 0;\n\n  return (\n    <Card>\n      <ToolbarTopicsMetrics\n        title={t('metrics.topic_metrics')}\n        timeDuration={timeDuration}\n        onSetTimeDuration={onTimeDuration}\n        isDisabled={backendUnavailable || noTopics}\n        isRefreshing={isRefreshing}\n        selectedTopic={selectedTopic}\n        onSetSelectedTopic={onSelectedTopic}\n        onRefresh={onRefresh}\n        topicList={topics}\n      />\n      {(() => {\n        switch (true) {\n          case isLoading && selectedTopic === undefined:\n            return (\n              <CardBody>\n                <Bullseye>\n                  <Spinner isSVG />\n                </Bullseye>\n              </CardBody>\n            );\n\n          case isLoading:\n            return (\n              <>\n                <TotalBytesTitle />\n                <ChartLoading />\n                <Divider />\n\n                <PartitionSizeTitle />\n                <ChartLoading />\n              </>\n            );\n\n          case backendUnavailable:\n            return (\n              <CardBody>\n                <EmptyStateMetricsUnavailable />\n              </CardBody>\n            );\n\n          case metricsDataUnavailable:\n            return (\n              <CardBody>\n                <EmptyStateNoTopicData />\n              </CardBody>\n            );\n\n          case noTopics:\n            return (\n              <CardBody>\n                <EmptyStateNoTopics onCreateTopic={onCreateTopic} />\n              </CardBody>\n            );\n\n          case selectedTopic !== undefined:\n            return (\n              <>\n                <TotalBytesTitle />\n                <CardBody>\n                  <ChartTotalBytes\n                    incomingTopicsData={incomingTopicsData}\n                    outgoingTopicsData={outgoingTopicsData}\n                    selectedTopic={selectedTopic}\n                    timeDuration={timeDuration}\n                  />\n                </CardBody>\n                <Divider />\n\n                <PartitionSizeTitle />\n                <CardBody>\n                  <ChartLogSizePerPartition\n                    partitions={partitions}\n                    timeDuration={timeDuration}\n                  />\n                </CardBody>\n              </>\n            );\n\n          default:\n            return (\n              <>\n                <TotalBytesTitle />\n                <CardBody>\n                  <ChartTotalBytes\n                    incomingTopicsData={incomingTopicsData}\n                    outgoingTopicsData={outgoingTopicsData}\n                    selectedTopic={selectedTopic}\n                    timeDuration={timeDuration}\n                  />\n                </CardBody>\n                <Divider />\n                <PartitionSizeTitle />\n                <CardBody>\n                  <EmptyStateNoTopicSelected />\n                </CardBody>\n              </>\n            );\n        }\n      })()}\n    </Card>\n  );\n};\n\nconst TotalBytesTitle: FunctionComponent = () => {\n  const { t } = useTranslation();\n  return (\n    <CardTitle component='h3'>\n      {t('metrics.total_bytes')}{' '}\n      <ChartPopover\n        title={t('metrics.total_bytes')}\n        description={t('metrics.topic_metrics_help_text')}\n      />\n    </CardTitle>\n  );\n};\n\nconst PartitionSizeTitle: FunctionComponent = () => {\n  const { t } = useTranslation();\n  return (\n    <CardTitle component='h3'>{t('metrics.topic_partition_size')}</CardTitle>\n  );\n};\n","import { TotalBytesMetrics } from '@app/modules/Metrics/MetricsApi';\nimport {\n  convertToSpecifiedByte,\n  dateToChartValue,\n  getLargestByteSize,\n  shouldShowDate,\n  SupportedSizes,\n} from '@app/modules/Metrics/utils';\nimport {\n  Chart,\n  ChartAxis,\n  ChartGroup,\n  ChartLegend,\n  ChartLine,\n  ChartThemeColor,\n  ChartVoronoiContainer,\n} from '@patternfly/react-charts';\nimport chart_color_blue_300 from '@patternfly/react-tokens/dist/js/chart_color_blue_300';\nimport chart_color_orange_300 from '@patternfly/react-tokens/dist/js/chart_color_orange_300';\nimport React, { FunctionComponent, useEffect, useRef, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\n\ntype ChartData = {\n  color: string;\n  line: TopicChartData[];\n};\n\ntype TopicChartData = {\n  name: string;\n  x: string;\n  y: number;\n};\n\ntype LegendData = {\n  name: string;\n  symbol: {\n    fill: string;\n    type?: string;\n  };\n};\n\ntype ChartTotalBytesProps = {\n  incomingTopicsData: TotalBytesMetrics;\n  outgoingTopicsData: TotalBytesMetrics;\n  selectedTopic: string | undefined;\n  timeDuration: number;\n};\nexport const ChartTotalBytes: FunctionComponent<ChartTotalBytesProps> = ({\n  incomingTopicsData,\n  outgoingTopicsData,\n  selectedTopic,\n  timeDuration,\n}) => {\n  const { t } = useTranslation();\n\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const [width, setWidth] = useState<number>();\n\n  const handleResize = () =>\n    containerRef.current && setWidth(containerRef.current.clientWidth);\n  const itemsPerRow = width && width > 650 ? 6 : 3;\n\n  useEffect(() => {\n    handleResize();\n    window.addEventListener('resize', handleResize);\n  }, [width]);\n\n  const { chartData, legendData, largestByteSize } = getBytesChartData(\n    incomingTopicsData,\n    outgoingTopicsData,\n    timeDuration,\n    t('{{topic}} incoming bytes', { topic: selectedTopic || t('Total') }),\n    t('{{topic}} outgoing bytes', { topic: selectedTopic || t('Total') })\n  );\n\n  return (\n    <div ref={containerRef}>\n      <Chart\n        ariaTitle={t('metrics.total_bytes')}\n        containerComponent={\n          <ChartVoronoiContainer\n            labels={({ datum }) => `${datum.name}: ${datum.y}`}\n            constrainToVisibleArea\n          />\n        }\n        legendAllowWrap={true}\n        legendPosition='bottom-left'\n        legendComponent={\n          <ChartLegend data={legendData} itemsPerRow={itemsPerRow} />\n        }\n        height={300}\n        padding={{\n          bottom: 110,\n          left: 90,\n          right: 30,\n          top: 25,\n        }}\n        themeColor={ChartThemeColor.multiUnordered}\n        width={width}\n      >\n        <ChartAxis label={'\\n' + 'Time'} tickCount={6} />\n        <ChartAxis\n          dependentAxis\n          tickFormat={(t) => `${Math.round(t)} ${largestByteSize}`}\n          tickCount={4}\n          minDomain={{ y: 0 }}\n        />\n        <ChartGroup>\n          {chartData.map((value, index) => (\n            <ChartLine\n              key={`chart-line-${index}`}\n              data={value.line}\n              style={{\n                data: {\n                  stroke: value.color,\n                },\n              }}\n            />\n          ))}\n        </ChartGroup>\n      </Chart>\n    </div>\n  );\n};\n\nexport function getBytesChartData(\n  incomingTopic: TotalBytesMetrics,\n  outgoingTopic: TotalBytesMetrics,\n  timeDuration: number,\n  incomingTopicName: string,\n  outgoingTopicName: string\n) {\n  const legendData: Array<LegendData> = [];\n  const chartData: Array<ChartData> = [];\n  const largestByteSize = getLargestByteSize(incomingTopic, outgoingTopic);\n\n  const incomingLine = metricsToLine(\n    incomingTopic,\n    timeDuration,\n    incomingTopicName,\n    largestByteSize\n  );\n  if (incomingLine) {\n    const color = chart_color_blue_300.value;\n    chartData.push({ color, line: incomingLine });\n    legendData.push({\n      name: incomingTopicName,\n      symbol: {\n        fill: color,\n      },\n    });\n  }\n\n  const outgoingLine = metricsToLine(\n    outgoingTopic,\n    timeDuration,\n    outgoingTopicName,\n    largestByteSize\n  );\n  if (outgoingLine) {\n    const color = chart_color_orange_300.value;\n    chartData.push({ color, line: outgoingLine });\n    legendData.push({\n      name: outgoingTopicName,\n      symbol: {\n        fill: color,\n      },\n    });\n  }\n  return {\n    legendData,\n    chartData,\n    largestByteSize,\n  };\n}\n\nfunction metricsToLine(\n  metrics: TotalBytesMetrics,\n  timeDuration: number,\n  name: string,\n  largestByteSize: SupportedSizes\n) {\n  const timestamps = Object.keys(metrics).map((ts) => parseInt(ts, 10));\n  if (timestamps.length > 0) {\n    const line: Array<TopicChartData> = [];\n    const currentLengthOfData = (() => {\n      const timestampDiff = timestamps[timestamps.length - 1] - timestamps[0];\n      const minutes = timestampDiff / 1000 / 60;\n      return minutes;\n    })();\n    const lengthOfData = 6 * 60 - currentLengthOfData;\n    const lengthOfDataPer5Mins = (6 * 60 - currentLengthOfData) / 5;\n\n    if (lengthOfData <= 360 && timeDuration >= 6) {\n      for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n        const newTimestamp =\n          timestamps[0] - (lengthOfDataPer5Mins - i) * (5 * 60000);\n        const date = new Date(newTimestamp);\n        const time = dateToChartValue(date, {\n          showDate: shouldShowDate(timeDuration),\n        });\n        line.push({ name, x: time, y: 0 });\n      }\n    }\n\n    Object.entries(metrics).map(([timestamp, bytes]) => {\n      const date = new Date(parseInt(timestamp, 10));\n      const time = dateToChartValue(date, {\n        showDate: shouldShowDate(timeDuration),\n      });\n      const convertedBytes = convertToSpecifiedByte(bytes, largestByteSize);\n      line.push({ name, x: time, y: convertedBytes });\n    });\n    return line;\n  }\n  return undefined;\n}\n","import {\n  convertToSpecifiedByte,\n  dateToChartValue,\n  shouldShowDate,\n} from '@app/modules/Metrics/utils';\nimport {\n  Chart,\n  ChartArea,\n  ChartAxis,\n  ChartGroup,\n  ChartLegend,\n  ChartThemeColor,\n  ChartThreshold,\n  ChartVoronoiContainer,\n} from '@patternfly/react-charts';\nimport chart_color_black_500 from '@patternfly/react-tokens/dist/js/chart_color_black_500';\nimport chart_color_blue_300 from '@patternfly/react-tokens/dist/js/chart_color_blue_300';\nimport React, { FunctionComponent, useEffect, useRef, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { TotalBytesMetrics } from '..';\nimport { DurationOptions } from './FilterByTime';\n\ntype ChartData = {\n  areaColor: string;\n  softLimitColor: string;\n  area: BrokerChartData[];\n  softLimit: BrokerChartData[];\n};\n\ntype BrokerChartData = {\n  name: string;\n  x: string;\n  y: number;\n};\n\ntype LegendData = {\n  name: string;\n  symbol?: {\n    fill?: string;\n    type?: string;\n  };\n};\n\ntype ChartUsedDiskSpaceProps = {\n  metrics: TotalBytesMetrics;\n  timeDuration: DurationOptions;\n};\n\nexport const ChartUsedDiskSpace: FunctionComponent<ChartUsedDiskSpaceProps> = ({\n  metrics,\n  timeDuration,\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const { t } = useTranslation();\n  const [width, setWidth] = useState<number>();\n  const usageLimit = 1000; // Replace with limit from API\n\n  const handleResize = () =>\n    containerRef.current && setWidth(containerRef.current.clientWidth);\n  const itemsPerRow = width && width > 650 ? 6 : 3;\n\n  useEffect(() => {\n    handleResize();\n    window.addEventListener('resize', handleResize);\n  }, [width]);\n\n  const { chartData, legendData, largestByteSize } = getChartData(\n    metrics,\n    timeDuration,\n    usageLimit,\n    t('Used disk space'),\n    t('Limit')\n  );\n\n  return (\n    <div ref={containerRef}>\n      <Chart\n        ariaTitle={t('metrics.used_disk_space')}\n        containerComponent={\n          <ChartVoronoiContainer\n            labels={({ datum }) => `${datum.name}: ${datum.y}`}\n            constrainToVisibleArea\n          />\n        }\n        legendPosition='bottom-left'\n        legendComponent={\n          <ChartLegend\n            orientation={'horizontal'}\n            data={legendData}\n            itemsPerRow={itemsPerRow}\n          />\n        }\n        height={350}\n        padding={{\n          bottom: 110, // Adjusted to accomodate legend\n          left: 90,\n          right: 60,\n          top: 25,\n        }}\n        themeColor={ChartThemeColor.multiUnordered}\n        width={width}\n        minDomain={{ y: 0 }}\n        legendAllowWrap={true}\n      >\n        <ChartAxis label={'\\n' + 'Time'} tickCount={6} />\n        <ChartAxis\n          dependentAxis\n          tickFormat={(t) => `${Math.round(t)} ${largestByteSize}`}\n          tickCount={4}\n        />\n        <ChartGroup>\n          {chartData.map((value, index) => (\n            <ChartArea\n              key={`chart-area-${index}`}\n              data={value.area}\n              interpolation='monotoneX'\n              style={{\n                data: {\n                  // TODO: check if this is needed\n                  // stroke: value.color,\n                },\n              }}\n            />\n          ))}\n        </ChartGroup>\n        <ChartThreshold\n          key={`chart-softlimit`}\n          data={chartData[0].softLimit}\n          style={{\n            data: {\n              stroke: chartData[0].softLimitColor,\n            },\n          }}\n        />\n      </Chart>\n    </div>\n  );\n};\n\nconst getChartData = (\n  metrics: TotalBytesMetrics,\n  timeDuration: number,\n  usageLimit: number,\n  lineLabel: string,\n  limitLabel: string\n) => {\n  const legendData: Array<LegendData> = [\n    {\n      name: limitLabel,\n      symbol: { fill: chart_color_black_500.value, type: 'threshold' },\n    },\n    { name: lineLabel, symbol: { fill: chart_color_blue_300.value } },\n  ];\n\n  const areaColor = chart_color_blue_300.value;\n  const softLimitColor = chart_color_black_500.value;\n  const chartData: Array<ChartData> = [];\n  const area: Array<BrokerChartData> = [];\n  const softLimit: Array<BrokerChartData> = [];\n  const largestByteSize = 'GiB'; // Hard code GiB as the largest byte size because there will always be a 20 GiB limit.\n\n  const timestamps = Object.keys(metrics).map((ts) => parseInt(ts, 10));\n  const currentLengthOfData = (() => {\n    const timestampDiff = timestamps[timestamps.length - 1] - timestamps[0];\n    const minutes = timestampDiff / 1000 / 60;\n    return minutes;\n  })();\n  const lengthOfData = 6 * 60 - currentLengthOfData;\n  const lengthOfDataPer5Mins = (6 * 60 - currentLengthOfData) / 5;\n\n  if (lengthOfData <= 360 && timeDuration >= 6) {\n    for (let i = 0; i < lengthOfDataPer5Mins; i = i + 1) {\n      const newTimestamp =\n        timestamps[0] - (lengthOfDataPer5Mins - i) * (5 * 60000);\n      const date = new Date(newTimestamp);\n      const time = dateToChartValue(date, {\n        showDate: shouldShowDate(timeDuration),\n      });\n      area.push({ name: lineLabel, x: time, y: 0 });\n      softLimit.push({ name: limitLabel, x: time, y: usageLimit });\n    }\n  }\n\n  Object.entries(metrics).map(([timestamp, bytes]) => {\n    const date = new Date(parseInt(timestamp));\n    const time = dateToChartValue(date, {\n      showDate: shouldShowDate(timeDuration),\n    });\n\n    const convertedBytes = convertToSpecifiedByte(bytes, largestByteSize);\n    area.push({ name: lineLabel, x: time, y: convertedBytes });\n    softLimit.push({ name: limitLabel, x: time, y: usageLimit });\n  });\n  chartData.push({ areaColor, softLimitColor, area, softLimit });\n\n  return {\n    legendData,\n    chartData,\n    largestByteSize,\n  };\n};\n","import React, { FunctionComponent } from 'react';\nimport {\n  Button,\n  CardActions,\n  CardHeader,\n  CardTitle,\n  Divider,\n  Toolbar,\n  ToolbarContent,\n  ToolbarItem,\n} from '@patternfly/react-core';\nimport SyncIcon from '@patternfly/react-icons/dist/js/icons/sync-icon';\nimport { DurationOptions, FilterByTime } from './FilterByTime';\n\ntype ToolbarUsedDiskSpaceProps = {\n  title: string;\n  isDisabled: boolean;\n  isRefreshing: boolean;\n  timeDuration: DurationOptions;\n  onSetTimeDuration: (value: DurationOptions) => void;\n  onRefresh: () => void;\n};\nexport const ToolbarUsedDiskSpace: FunctionComponent<ToolbarUsedDiskSpaceProps> =\n  ({\n    title,\n    isDisabled,\n    isRefreshing,\n    timeDuration,\n    onSetTimeDuration,\n    onRefresh,\n  }) => {\n    return (\n      <>\n        <CardHeader>\n          <CardTitle component='h2'>{title}</CardTitle>\n          <CardActions>\n            <Toolbar>\n              <ToolbarContent>\n                <FilterByTime\n                  timeDuration={timeDuration}\n                  onDurationChange={onSetTimeDuration}\n                  keyText={'kafka-metrics-time-filter'}\n                  disableToolbar={isDisabled}\n                />\n                <ToolbarItem>\n                  <Button\n                    isLoading={isRefreshing}\n                    variant='plain'\n                    aria-label='sync'\n                    onClick={onRefresh}\n                  >\n                    {!isRefreshing && <SyncIcon />}\n                  </Button>\n                </ToolbarItem>\n              </ToolbarContent>\n            </Toolbar>\n          </CardActions>\n        </CardHeader>\n        <Divider />\n      </>\n    );\n  };\n","import { Card, CardBody, CardTitle } from '@patternfly/react-core';\nimport React, { FunctionComponent } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { TotalBytesMetrics } from '../MetricsApi';\nimport { ChartLoading } from './ChartLoading';\nimport { ChartPopover } from './ChartPopover';\nimport { ChartUsedDiskSpace } from './ChartUsedDiskSpace';\nimport { EmptyStateMetricsUnavailable } from './EmptyStateMetricsUnavailable';\nimport { DurationOptions } from './FilterByTime';\nimport { ToolbarUsedDiskSpace } from './ToolbarUsedDiskSpace';\n\ntype CardUsedDiskSpaceProps = {\n  metrics: TotalBytesMetrics;\n  timeDuration: DurationOptions;\n  metricsDataUnavailable: boolean;\n  isLoading: boolean;\n  isRefreshing: boolean;\n  onRefresh: () => void;\n  onTimeDuration: (duration: DurationOptions) => void;\n};\n\nexport const CardUsedDiskSpace: FunctionComponent<CardUsedDiskSpaceProps> = ({\n  metrics,\n  timeDuration,\n  metricsDataUnavailable,\n  isLoading,\n  isRefreshing,\n  onRefresh,\n  onTimeDuration,\n}) => {\n  const { t } = useTranslation();\n\n  return (\n    <Card>\n      <ToolbarUsedDiskSpace\n        title={t('metrics.kafka_instance_metrics')}\n        timeDuration={timeDuration}\n        onSetTimeDuration={onTimeDuration}\n        isDisabled={metricsDataUnavailable}\n        isRefreshing={isRefreshing}\n        onRefresh={onRefresh}\n      />\n      {(() => {\n        switch (true) {\n          case isLoading:\n            return (\n              <>\n                <UsedDiskSpaceTitle />\n                <ChartLoading />\n              </>\n            );\n\n          case metricsDataUnavailable:\n            return (\n              <CardBody>\n                <EmptyStateMetricsUnavailable />\n              </CardBody>\n            );\n\n          default:\n            return (\n              <>\n                <UsedDiskSpaceTitle />\n                <CardBody>\n                  <ChartUsedDiskSpace\n                    metrics={metrics}\n                    timeDuration={timeDuration}\n                  />\n                </CardBody>\n              </>\n            );\n        }\n      })()}\n    </Card>\n  );\n};\n\nconst UsedDiskSpaceTitle: FunctionComponent = () => {\n  const { t } = useTranslation();\n  return (\n    <CardTitle component='h3'>\n      {t('metrics.used_disk_space')}{' '}\n      <ChartPopover\n        title={t('metrics.used_disk_space')}\n        description={t('metrics.used_disk_space_help_text')}\n      />\n    </CardTitle>\n  );\n};\n","import { TotalBytesMetrics } from '@app/modules/Metrics';\nimport { createModel } from 'xstate/lib/model';\nimport { DurationOptions } from '../components/FilterByTime';\n\nconst MAX_RETRIES = 3;\n\ntype FetchSuccessProps = {\n  metrics: TotalBytesMetrics;\n};\n\nexport const DiskSpaceMetricsModel = createModel(\n  {\n    // from the UI elements\n    timeDuration: 60 as DurationOptions,\n\n    // from the api\n    metrics: {} as TotalBytesMetrics,\n    // how many time did we try a fetch (that combines more api)\n    fetchFailures: 0 as number,\n  },\n  {\n    events: {\n      // called when a new kafka id has been specified\n      fetch: () => ({}),\n      fetchSuccess: (value: FetchSuccessProps) => ({ ...value }),\n      fetchFail: () => ({}),\n\n      // to refresh the data\n      refresh: () => ({}),\n\n      // from the UI elements\n      selectTopic: (topic: string | undefined) => ({\n        selectedTopic: topic,\n      }),\n      selectDuration: (duration: DurationOptions) => ({\n        timeDuration: duration,\n      }),\n    },\n  }\n);\n\nconst setMetrics = DiskSpaceMetricsModel.assign((_, event) => {\n  const { metrics } = event;\n  return {\n    metrics,\n  };\n}, 'fetchSuccess');\n\nconst incrementRetries = DiskSpaceMetricsModel.assign(\n  {\n    fetchFailures: (context) => context.fetchFailures + 1,\n  },\n  'fetchFail'\n);\n\nconst resetRetries = DiskSpaceMetricsModel.assign(\n  {\n    fetchFailures: () => 0,\n  },\n  'refresh'\n);\n\nconst setDuration = DiskSpaceMetricsModel.assign(\n  {\n    timeDuration: (_, event) => event.timeDuration,\n  },\n  'selectDuration'\n);\n\nexport const DiskSpaceMetricsMachine = DiskSpaceMetricsModel.createMachine(\n  {\n    id: 'diskSpace',\n    context: DiskSpaceMetricsModel.initialContext,\n    initial: 'callApi',\n    states: {\n      callApi: {\n        tags: 'loading',\n        initial: 'loading',\n        states: {\n          loading: {\n            invoke: {\n              src: 'api',\n            },\n            on: {\n              fetchSuccess: {\n                actions: setMetrics,\n                target: '#diskSpace.verifyData',\n              },\n              fetchFail: {\n                actions: incrementRetries,\n                target: 'failure',\n              },\n            },\n          },\n          failure: {\n            after: {\n              1000: [\n                { cond: 'canRetryFetching', target: 'loading' },\n                { target: '#diskSpace.criticalFail' },\n              ],\n            },\n          },\n        },\n      },\n      criticalFail: {\n        tags: 'failed',\n        on: {\n          refresh: {\n            actions: resetRetries,\n            target: 'callApi',\n          },\n        },\n      },\n      verifyData: {\n        always: [\n          { cond: 'hasMetrics', target: 'withMetrics' },\n          { target: 'noData' },\n        ],\n      },\n      noData: {\n        tags: 'no-data',\n        on: {\n          refresh: {\n            actions: resetRetries,\n            target: 'callApi',\n          },\n          selectDuration: {\n            actions: setDuration,\n            target: 'refreshing',\n          },\n        },\n      },\n      withMetrics: {\n        on: {\n          refresh: {\n            target: 'refreshing',\n          },\n          selectDuration: {\n            actions: setDuration,\n            target: 'refreshing',\n          },\n        },\n      },\n      refreshing: {\n        tags: 'refreshing',\n        invoke: {\n          src: 'api',\n        },\n        on: {\n          fetchSuccess: {\n            actions: setMetrics,\n            target: 'verifyData',\n          },\n          fetchFail: {\n            //  we silently ignore this happened and go back to the right\n            // state depending on the previous data\n            target: 'verifyData',\n          },\n        },\n      },\n    },\n  },\n  {\n    guards: {\n      canRetryFetching: (context) => context.fetchFailures < MAX_RETRIES,\n      hasMetrics: (context) => Object.keys(context.metrics).length > 0,\n    },\n  }\n);\n\nexport type DiskSpaceMachineType = typeof DiskSpaceMetricsMachine;\n","import { createModel } from 'xstate/lib/model';\nimport { DurationOptions } from '../components/FilterByTime';\nimport { PartitionBytesMetric, TotalBytesMetrics } from '../MetricsApi';\n\nconst MAX_RETRIES = 3;\n\ntype FetchSuccessProps = {\n  kafkaTopics: string[];\n  metricsTopics: string[];\n  bytesOutgoing: TotalBytesMetrics;\n  bytesIncoming: TotalBytesMetrics;\n  bytesPerPartition: PartitionBytesMetric;\n};\n\nexport const TopicsMetricsModel = createModel(\n  {\n    // from the UI elements\n    selectedTopic: undefined as string | undefined,\n    timeDuration: 60 as DurationOptions,\n\n    // from the api\n    kafkaTopics: [] as string[],\n    metricsTopics: [] as string[],\n    bytesOutgoing: {} as TotalBytesMetrics,\n    bytesIncoming: {} as TotalBytesMetrics,\n    bytesPerPartition: {} as PartitionBytesMetric,\n\n    // how many time did we try a fetch (that combines more api)\n    fetchFailures: 0 as number,\n  },\n  {\n    events: {\n      // called when a new kafka id has been specified\n      fetch: () => ({}),\n      fetchSuccess: (value: FetchSuccessProps) => ({ ...value }),\n      fetchFail: () => ({}),\n\n      // to refresh the data\n      refresh: () => ({}),\n\n      // from the UI elements\n      selectTopic: (topic: string | undefined) => ({\n        selectedTopic: topic,\n      }),\n      selectDuration: (duration: DurationOptions) => ({\n        timeDuration: duration,\n      }),\n    },\n  }\n);\n\nconst setMetrics = TopicsMetricsModel.assign((_, event) => {\n  const {\n    kafkaTopics,\n    metricsTopics,\n    bytesPerPartition,\n    bytesIncoming,\n    bytesOutgoing,\n  } = event;\n  return {\n    kafkaTopics,\n    metricsTopics,\n    bytesPerPartition,\n    bytesIncoming,\n    bytesOutgoing,\n  };\n}, 'fetchSuccess');\n\nconst incrementRetries = TopicsMetricsModel.assign(\n  {\n    fetchFailures: (context) => context.fetchFailures + 1,\n  },\n  'fetchFail'\n);\n\nconst resetRetries = TopicsMetricsModel.assign(\n  {\n    fetchFailures: () => 0,\n  },\n  'refresh'\n);\n\nconst setTopic = TopicsMetricsModel.assign(\n  {\n    selectedTopic: (_, event) => event.selectedTopic,\n  },\n  'selectTopic'\n);\n\nconst setDuration = TopicsMetricsModel.assign(\n  {\n    timeDuration: (_, event) => event.timeDuration,\n  },\n  'selectDuration'\n);\n\nexport const TopicsMetricsMachine = TopicsMetricsModel.createMachine(\n  {\n    id: 'topics',\n    context: TopicsMetricsModel.initialContext,\n    initial: 'callApi',\n    states: {\n      callApi: {\n        tags: 'loading',\n        initial: 'loading',\n        states: {\n          loading: {\n            invoke: {\n              src: 'api',\n            },\n            on: {\n              fetchSuccess: {\n                actions: setMetrics,\n                target: '#topics.verifyData',\n              },\n              fetchFail: {\n                actions: incrementRetries,\n                target: 'failure',\n              },\n            },\n          },\n          failure: {\n            after: {\n              1000: [\n                { cond: 'canRetryFetching', target: 'loading' },\n                { target: '#topics.criticalFail' },\n              ],\n            },\n          },\n        },\n      },\n      criticalFail: {\n        tags: 'failed',\n        on: {\n          refresh: {\n            actions: resetRetries,\n            target: 'callApi',\n          },\n        },\n      },\n      verifyData: {\n        always: [\n          { cond: 'hasMetrics', target: 'withTopics' },\n          { target: 'noData' },\n        ],\n      },\n      noData: {\n        tags: 'no-data',\n        initial: 'idle',\n        states: {\n          idle: {},\n          refreshing: {\n            tags: 'refreshing',\n            invoke: {\n              src: 'api',\n            },\n            on: {\n              fetchSuccess: {\n                actions: setMetrics,\n                target: '#topics.verifyData',\n              },\n              fetchFail: {\n                //  we silently ignore this happened\n                target: '#topics.noData',\n              },\n            },\n          },\n        },\n        on: {\n          refresh: {\n            target: '#topics.noData.refreshing',\n          },\n          selectTopic: {\n            actions: setTopic,\n            target: '#topics.noData.refreshing',\n          },\n          selectDuration: {\n            actions: setDuration,\n            target: '#topics.noData.refreshing',\n          },\n        },\n      },\n      withTopics: {\n        initial: 'idle',\n        states: {\n          idle: {},\n          refreshing: {\n            tags: 'refreshing',\n            invoke: {\n              src: 'api',\n            },\n            on: {\n              fetchSuccess: {\n                actions: setMetrics,\n                target: '#topics.verifyData',\n              },\n              fetchFail: {\n                //  we silently ignore this happened\n                target: '#topics.withTopics',\n              },\n            },\n          },\n        },\n        on: {\n          refresh: {\n            target: '#topics.withTopics.refreshing',\n          },\n          selectTopic: {\n            actions: setTopic,\n            target: '#topics.withTopics.refreshing',\n          },\n          selectDuration: {\n            actions: setDuration,\n            target: '#topics.withTopics.refreshing',\n          },\n        },\n      },\n    },\n  },\n  {\n    guards: {\n      canRetryFetching: (context) => context.fetchFailures < MAX_RETRIES,\n      hasMetrics: (context) => {\n        const hasSomeTopics =\n          context.kafkaTopics.length > 0 || context.metricsTopics.length > 0;\n        const hasSomeMetrics =\n          Object.keys(context.bytesIncoming).length > 0 ||\n          Object.keys(context.bytesOutgoing).length > 0;\n        return hasSomeTopics && hasSomeMetrics;\n      },\n    },\n  }\n);\n\nexport type TopicsMetricsMachineType = typeof TopicsMetricsMachine;\n","import { useAuth, useConfig } from '@rhoas/app-services-ui-shared';\nimport { useInterpret } from '@xstate/react';\nimport React, { createContext, FunctionComponent } from 'react';\nimport { InterpreterFrom } from 'xstate';\nimport {\n  DiskSpaceMetricsMachine,\n  TopicsMetricsMachineType,\n  TopicsMetricsMachine,\n  TopicsMetricsModel,\n  DiskSpaceMachineType,\n  DiskSpaceMetricsModel,\n} from './machines';\nimport { fetchDiskSpaceMetrics, fetchTopicsMetrics } from './MetricsApi';\nimport { timeIntervalsMapping } from './utils';\n\ntype MetricsContextProps = {\n  kafkaId: string;\n  kafkaApiPath: string;\n  topicsMetricsMachineService: InterpreterFrom<TopicsMetricsMachineType>;\n  diskSpaceMetricsMachineService: InterpreterFrom<DiskSpaceMachineType>;\n};\nexport const MetricsContext = createContext<MetricsContextProps>(null!);\n\ntype MetricsProviderProps = {\n  kafkaId: string;\n  kafkaApiPath: string;\n};\n\nexport const MetricsProvider: FunctionComponent<MetricsProviderProps> = ({\n  kafkaId,\n  kafkaApiPath,\n  children,\n}) => {\n  const topicsMetricsMachineService = useTopicsMetricsMachineService(\n    kafkaId,\n    kafkaApiPath\n  );\n  const diskSpaceMetricsMachineService =\n    useDiskSpaceMetricsMachineService(kafkaId);\n  return (\n    <MetricsContext.Provider\n      value={{\n        kafkaId,\n        kafkaApiPath,\n        diskSpaceMetricsMachineService,\n        topicsMetricsMachineService,\n      }}\n    >\n      {children}\n    </MetricsContext.Provider>\n  );\n};\n\nfunction useTopicsMetricsMachineService(kafkaId: string, kafkaApiPath: string) {\n  const auth = useAuth();\n  const { kas } = useConfig() || {};\n  const { apiBasePath: basePath } = kas || {};\n\n  return useInterpret(\n    TopicsMetricsMachine.withConfig({\n      services: {\n        api: (context) => {\n          return (callback) => {\n            fetchTopicsMetrics({\n              kafkaId: kafkaId,\n              selectedTopic: context.selectedTopic,\n              timeDuration: context.timeDuration,\n              timeInterval: timeIntervalsMapping[context.timeDuration],\n              accessToken: auth.kas.getToken(),\n              basePath: basePath,\n              kafkaApiPath,\n            })\n              .then((results) =>\n                callback(TopicsMetricsModel.events.fetchSuccess(results))\n              )\n              .catch((e) => {\n                console.error('Failed fetching data', e);\n                callback(TopicsMetricsModel.events.fetchFail());\n              });\n          };\n        },\n      },\n    }),\n    {\n      devTools: true,\n    }\n  );\n}\nfunction useDiskSpaceMetricsMachineService(kafkaId: string) {\n  const auth = useAuth();\n  const { kas } = useConfig() || {};\n  const { apiBasePath: basePath } = kas || {};\n\n  return useInterpret(\n    DiskSpaceMetricsMachine.withConfig({\n      services: {\n        api: (context) => {\n          return (callback) => {\n            fetchDiskSpaceMetrics({\n              kafkaId: kafkaId,\n              timeDuration: context.timeDuration,\n              timeInterval: timeIntervalsMapping[context.timeDuration],\n              accessToken: auth.kas.getToken(),\n              basePath: basePath,\n            })\n              .then((results) =>\n                callback(\n                  DiskSpaceMetricsModel.events.fetchSuccess({\n                    metrics: results,\n                  })\n                )\n              )\n              .catch((e) => {\n                console.error('Failed fetching data', e);\n                callback(DiskSpaceMetricsModel.events.fetchFail());\n              });\n          };\n        },\n      },\n    }),\n    {\n      devTools: true,\n    }\n  );\n}\n","import { useSelector } from '@xstate/react';\nimport { useCallback, useContext } from 'react';\nimport { DurationOptions } from './components/FilterByTime';\nimport { DiskSpaceMetricsModel } from './machines';\nimport { MetricsContext } from './MetricsProvider';\n\nexport function useDiskSpace() {\n  const { diskSpaceMetricsMachineService: service } =\n    useContext(MetricsContext);\n\n  const selector = useCallback(\n    (state: typeof service.state) => ({\n      ...state.context,\n      isRefreshing: state.hasTag('refreshing'),\n      isLoading: state.hasTag('loading'),\n      isFailed: state.hasTag('failed'),\n      isDataUnavailable: state.hasTag('no-data'),\n    }),\n    []\n  );\n  const {\n    metrics,\n    timeDuration,\n    isLoading,\n    isRefreshing,\n    isDataUnavailable,\n    isFailed,\n  } = useSelector(service, selector);\n\n  const onDurationChange = useCallback(\n    (duration: DurationOptions) =>\n      service.send(DiskSpaceMetricsModel.events.selectDuration(duration)),\n    [service]\n  );\n\n  const onRefresh = useCallback(\n    () => service.send(DiskSpaceMetricsModel.events.refresh()),\n    [service]\n  );\n\n  return {\n    metrics,\n    isLoading,\n    isRefreshing,\n    isFailed,\n    isDataUnavailable,\n    timeDuration,\n    onDurationChange,\n    onRefresh,\n  };\n}\n","import {\n  CardTopicsMetrics,\n  EmptyStateInitialLoading,\n  EmptyStateMetricsUnavailable,\n} from '@app/modules/Metrics/components';\nimport React, { FunctionComponent } from 'react';\nimport { MetricsLayout } from './components';\nimport { CardUsedDiskSpace } from './components/CardUsedDiskSpace';\nimport { MetricsProvider } from './MetricsProvider';\nimport { useDiskSpace } from './useDiskSpace';\nimport { useTopicsMetrics } from './useTopicsMetrics';\n\nexport interface MetricsProps {\n  kafkaId: string;\n  apiBasePath: string;\n  onCreateTopic: () => void;\n}\n\nexport const Metrics: FunctionComponent<MetricsProps> = ({\n  kafkaId,\n  apiBasePath,\n  onCreateTopic,\n}) => {\n  return (\n    <MetricsProvider kafkaId={kafkaId} kafkaApiPath={apiBasePath}>\n      <ConnectedMetrics onCreateTopic={onCreateTopic} />\n    </MetricsProvider>\n  );\n};\n\ntype ConnectedMetricsProps = {\n  onCreateTopic: () => void;\n};\nconst ConnectedMetrics: FunctionComponent<ConnectedMetricsProps> = ({\n  onCreateTopic,\n}) => {\n  const { isLoading, isFailed } = useDiskSpace();\n\n  switch (true) {\n    case isLoading:\n      return <EmptyStateInitialLoading />;\n    case isFailed:\n      return <EmptyStateMetricsUnavailable />;\n  }\n  return (\n    <MetricsLayout\n      diskSpaceMetrics={<ConnectedDiskMetrics />}\n      topicMetrics={<ConnectedTopicsMetrics onCreateTopic={onCreateTopic} />}\n    />\n  );\n};\n\nconst ConnectedDiskMetrics: FunctionComponent = () => {\n  const {\n    isLoading,\n    isRefreshing,\n    isDataUnavailable,\n    isFailed,\n    timeDuration,\n    metrics,\n    onDurationChange,\n    onRefresh,\n  } = useDiskSpace();\n\n  return (\n    <CardUsedDiskSpace\n      metrics={metrics}\n      timeDuration={timeDuration}\n      metricsDataUnavailable={isDataUnavailable || isFailed}\n      isLoading={isLoading}\n      isRefreshing={isRefreshing}\n      onRefresh={onRefresh}\n      onTimeDuration={onDurationChange}\n    />\n  );\n};\n\ntype ConnectedTopicsMetricsProps = {\n  onCreateTopic: () => void;\n};\nconst ConnectedTopicsMetrics: FunctionComponent<ConnectedTopicsMetricsProps> =\n  ({ onCreateTopic }) => {\n    const {\n      isLoading,\n      isRefreshing,\n      isFailed,\n      isDataUnavailable,\n      selectedTopic,\n      timeDuration,\n      topics,\n      bytesIncoming,\n      bytesOutgoing,\n      bytesPerPartition,\n      onDurationChange,\n      onTopicChange,\n      onRefresh,\n    } = useTopicsMetrics();\n\n    return (\n      <CardTopicsMetrics\n        backendUnavailable={isFailed}\n        metricsDataUnavailable={isDataUnavailable}\n        topics={topics}\n        incomingTopicsData={bytesIncoming}\n        outgoingTopicsData={bytesOutgoing}\n        partitions={bytesPerPartition}\n        timeDuration={timeDuration}\n        isLoading={isLoading}\n        isRefreshing={isRefreshing}\n        selectedTopic={selectedTopic}\n        onRefresh={onRefresh}\n        onSelectedTopic={onTopicChange}\n        onTimeDuration={onDurationChange}\n        onCreateTopic={onCreateTopic}\n      />\n    );\n  };\n","import { useSelector } from '@xstate/react';\nimport { useCallback, useContext, useMemo } from 'react';\nimport { DurationOptions } from './components/FilterByTime';\nimport { TopicsMetricsModel } from './machines';\nimport { MetricsContext } from './MetricsProvider';\n\nexport function useTopicsMetrics() {\n  const { topicsMetricsMachineService: service } = useContext(MetricsContext);\n\n  const selector = useCallback(\n    (state: typeof service.state) => ({\n      ...state.context,\n      isRefreshing: state.hasTag('refreshing'),\n      isLoading: state.hasTag('loading'),\n      isFailed: state.hasTag('failed'),\n      isDataUnavailable: state.hasTag('no-data'),\n    }),\n    []\n  );\n  const {\n    selectedTopic,\n    timeDuration,\n    kafkaTopics,\n    metricsTopics,\n    bytesIncoming,\n    bytesOutgoing,\n    bytesPerPartition,\n    isLoading,\n    isRefreshing,\n    isDataUnavailable,\n    isFailed,\n  } = useSelector(service, selector);\n\n  const onTopicChange = useCallback(\n    (topic: string | undefined) =>\n      service.send(TopicsMetricsModel.events.selectTopic(topic)),\n    [service]\n  );\n\n  const onDurationChange = useCallback(\n    (duration: DurationOptions) =>\n      service.send(TopicsMetricsModel.events.selectDuration(duration)),\n    [service]\n  );\n\n  const onRefresh = useCallback(\n    () => service.send(TopicsMetricsModel.events.refresh()),\n    [service]\n  );\n\n  const mergedTopics = useMemo((): string[] => {\n    const topics = Array.from(\n      new Set<string>([...kafkaTopics, ...metricsTopics])\n    );\n    topics.sort((a, b) => a.localeCompare(b));\n    return topics;\n  }, [kafkaTopics, metricsTopics]);\n\n  return {\n    isLoading,\n    isRefreshing,\n    isFailed,\n    isDataUnavailable,\n    topics: mergedTopics,\n    selectedTopic,\n    timeDuration,\n    bytesIncoming,\n    bytesOutgoing,\n    bytesPerPartition,\n    onTopicChange,\n    onDurationChange,\n    onRefresh,\n  };\n}\n"],"names":["ChartPopover","title","description","Popover","headerContent","bodyContent","EmptyStateInitialLoading","EmptyState","variant","EmptyStateVariant","EmptyStateBody","EmptyStateMetricsUnavailable","t","useTranslation","EmptyStateIcon","icon","TachometerAltIcon","Title","headingLevel","size","EmptyStateNoTopicData","SearchIcon","EmptyStateNoTopics","onCreateTopic","WrenchIcon","Button","onClick","EmptyStateNoTopicSelected","FilterIcon","DurationOptionsMap","FilterByTime","timeDuration","keyText","disableToolbar","onDurationChange","useState","isTimeSelectOpen","setIsTimeSelectOpen","ToolbarItem","Select","SelectVariant","onToggle","onSelect","_","selection","mapping","Object","entries","find","parseInt","selections","isOpen","isDisabled","placeholderText","SelectGroup","label","key","values","map","idx","SelectOption","value","timeOptions","widths","default","sm","md","lg","xl","FilterByTopic","selectedTopic","topicList","onSetSelectedTopic","isTopicSelectOpen","setIsTopicSelectOpen","allTopicsLabel","topicOptions","topic","index","length","undefined","onFilter","textInput","filteredTopics","filter","indexOf","isGrouped","hasInlineFilter","style","width","getLargestByteSize","data1","data2","currentByteSize","sortedData","data","datum","bytes","forEach","byteString","unit","convertToSpecifiedByte","largestByteSize","Math","round","shouldShowDate","dateToChartValue","date","showDate","toISOString","split","dateValue","timeValue","slice","timeIntervalsMapping","colors","chart_color_blue_300","ChartLogSizePerPartition","partitions","containerRef","useRef","setWidth","handleResize","current","clientWidth","itemsPerRow","useEffect","window","addEventListener","legendData","chartData","name","dataMap","timestamps","keys","s","color","push","area","getCurrentLengthOfData","lengthOfData","lengthOfDataPer5Mins","i","newtimestamp","Date","time","x","y","timestamp","getLogSizePerPartitionChartData","ref","Chart","ariaTitle","containerComponent","ChartVoronoiContainer","labels","constrainToVisibleArea","legendPosition","legendComponent","ChartLegend","height","padding","bottom","left","right","top","themeColor","ChartThemeColor","legendAllowWrap","ChartAxis","tickCount","dependentAxis","tickFormat","ChartGroup","ChartArea","interpolation","MetricsLayout","diskSpaceMetrics","topicMetrics","PageSection","Grid","hasGutter","GridItem","ToolbarTopicsMetrics","isRefreshing","onSetTimeDuration","onRefresh","CardHeader","CardTitle","component","CardActions","Toolbar","ToolbarContent","isLoading","Divider","ChartLoading","CardBody","Bullseye","Spinner","isSVG","CardTopicsMetrics","topics","incomingTopicsData","outgoingTopicsData","backendUnavailable","metricsDataUnavailable","onSelectedTopic","onTimeDuration","noTopics","Card","TotalBytesTitle","PartitionSizeTitle","ChartTotalBytes","incomingTopic","outgoingTopic","incomingTopicName","outgoingTopicName","incomingLine","metricsToLine","line","symbol","fill","outgoingLine","chart_color_orange_300","getBytesChartData","minDomain","ChartLine","stroke","metrics","ts","currentLengthOfData","newTimestamp","convertedBytes","ChartUsedDiskSpace","getChartData","orientation","ChartThreshold","softLimit","softLimitColor","usageLimit","lineLabel","limitLabel","chart_color_black_500","type","areaColor","ToolbarUsedDiskSpace","CardUsedDiskSpace","UsedDiskSpaceTitle","DiskSpaceMetricsModel","createModel","fetchFailures","events","fetch","fetchSuccess","fetchFail","refresh","selectTopic","selectDuration","duration","setMetrics","assign","event","incrementRetries","context","resetRetries","setDuration","DiskSpaceMetricsMachine","createMachine","id","initialContext","initial","states","callApi","tags","loading","invoke","src","on","actions","target","failure","after","cond","criticalFail","verifyData","always","noData","withMetrics","refreshing","guards","canRetryFetching","hasMetrics","TopicsMetricsModel","kafkaTopics","metricsTopics","bytesOutgoing","bytesIncoming","bytesPerPartition","setTopic","TopicsMetricsMachine","idle","withTopics","hasSomeTopics","hasSomeMetrics","MetricsContext","createContext","MetricsProvider","kafkaId","kafkaApiPath","children","topicsMetricsMachineService","auth","useAuth","basePath","useConfig","useInterpret","withConfig","services","api","callback","timeInterval","accessToken","kas","getToken","then","results","catch","e","console","error","devTools","useTopicsMetricsMachineService","diskSpaceMetricsMachineService","useDiskSpaceMetricsMachineService","Provider","useDiskSpace","service","useContext","selector","useCallback","state","hasTag","isFailed","isDataUnavailable","useSelector","send","Metrics","apiBasePath","ConnectedMetrics","ConnectedDiskMetrics","ConnectedTopicsMetrics","onTopicChange","useMemo","Array","from","Set","sort","a","b","localeCompare","useTopicsMetrics"],"sourceRoot":""}